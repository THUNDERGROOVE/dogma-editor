# Don't look at this, thx

import sqlite3

def write_header(_f):
    _f.write("/* Generated by codegen.py\n")
    _f.write(" * DO NOT EDIT\n")
    _f.write(" */\n\n\n")
    

db = sqlite3.connect("bulkdata.db")

f = open("src/cache_types.h", "w")

write_header(f)

f.write("#ifndef __CACHE_TYPES__H__\n")
f.write("#define __CACHE_TYPES__H__\n\n")

f.write('#include <stdio.h>\n\n')
f.write('#include <vector>\n\n')
f.write('#include "bulkdata.h"\n\n')

f.write("struct bulkdata;\n")
f.write("struct edit_window;\n")


cursor = db.cursor()
cursor.execute("SELECT * from sqlite_master WHERE type='table';")
tables = {}


for x in cursor.fetchall():
    schema = x[-1]
    schema = schema.split("(")[1]
    schema = schema.split(")")[0]
    schema = schema.split(",")
    schema = [c.strip(' ') for c in schema]
    n = []
    for b in schema:
       n.append((
           b.split(" ")[0],
           b.split(" ")[1]))
    schema = n
    tables[x[1]] = schema

for k, v in tables.iteritems():
    f.write("struct " + k + " {\n")

    for x in v:
        if x[1] == "INTEGER":
            f.write("    uint32_t ")
        if x[1] == "REAL":
            f.write("    float ")
        if x[1] == "TEXT":
            f.write("    char *")
        
        f.write(x[0]+ ";\n")

    f.write("\n    bool dirty;\n")

    f.write("};\n\n")


# f.write("enum cache_tag {\n")
# for k, v in tables.iteritems():
#     if v[0][1] != "INTEGER":
#         print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
#         continue
#     f.write("    tag_" + k + ",\n")
# f.write("};\n\n")

for k, v in tables.iteritems():
    if v[0][1] != "INTEGER":
        print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
        continue
    f.write(k + " " + k + "_load_by(bulkdata *b, uint32_t " + v[0][0] + ");\n")

for k, v in tables.iteritems():
    if v[0][1] != "INTEGER":
        print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
        continue
    f.write("std::vector<" + k + "> " + k + "_load_all(bulkdata *b);\n")

f.write("\n")
print "Generating cache struct"

f.write("struct cache_collection {\n")
for k, v in tables.iteritems():
    if v[0][1] != "INTEGER":
        print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
        continue
    f.write("    std::vector<" + k + "> cache_" + k + ";\n")

f.write("};\n\n")

f.write("cache_collection cache_load_all(bulkdata *b);\n")

for k, v in tables.iteritems():
    if v[0][1] != "INTEGER":
        print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
        continue
    f.write("void " + k + "_draw_edit(edit_window *e);\n")

f.write("\n\n")


f.write("#endif\n")

f.close()

f = open("src/cache_funcs.cpp", "w")
write_header(f)

f.write('#include "cache_types.h"\n\n')
f.write('#include <string.h>\n\n')
f.write('#include "bulkdata.h"\n\n')
f.write('#include <list>\n\n')
f.write('#include "imgui.h"\n\n')


for k, v in tables.iteritems():
    if v[0][1] != "INTEGER":
        print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
        continue
    f.write(k + " " + k + "_load_by(bulkdata *b, uint32_t " + v[0][0] + ") {\n")

    f.write("    char *err_msg = NULL;\n")
    f.write("    sqlite3_stmt *res;\n")


    f.write("    " + k + " t;\n")
    f.write("    memset(&t, 0, sizeof(t));\n")

    f.write('    char *stmt = (char *)"SELECT * from ' + k + ' where typeID = @id";\n');

    f.write("    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);\n");

    f.write("    if (rc == SQLITE_OK) {\n")
    f.write('        int idx = sqlite3_bind_parameter_index(res, "@id");\n')
    f.write('        sqlite3_bind_int(res, idx, ' + v[0][0] + ');\n')
    f.write("    } else {\n")
    f.write('        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));\n')
    f.write("    }\n\n")
    f.write("    int step = sqlite3_step(res);\n")

    f.write("    if (step == SQLITE_ROW) {\n")

    i = 0
    for x in v:
        name = x[0]
        _type = x[1]
        if _type == "INTEGER":
            f.write("        t." + name + " = sqlite3_column_int(res, " + str(i) + ");\n")
        elif _type == "REAL":
            f.write("        t." + name + " = sqlite3_column_double(res, " + str(i) + ");\n")
        elif _type == "TEXT":
            f.write("        char *_v" + str(i) +" = (char *)sqlite3_column_text(res, " + str(i) + ");\n")
            f.write("        if (_v" + str(i) + " != NULL) {\n")
            f.write("            t." + name + " = strdup(_v" + str(i) + ");\n")
            f.write("        }\n")
        i = i + 1
    f.write("    }\n\n");
    f.write("    sqlite3_finalize(res);\n")
    f.write("    return t;\n")
    f.write("}\n\n")

print "Generating loadalls"

for k, v in tables.iteritems():
    if v[0][1] != "INTEGER":
        print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
        continue
    f.write("std::vector<" + k + "> " + k + "_load_all(bulkdata *b) {\n")
    f.write('    printf("Loading ' + k + '\\n");\n')

    f.write("    std::vector<" + k + "> out;\n")


    f.write("    sqlite3_stmt *res;\n")


    f.write("    " + k + " t;\n")
    f.write("    memset(&t, 0, sizeof(t));\n")

    f.write('    char *stmt = (char *)"SELECT * from ' + k + '";\n');

    f.write("    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);\n");

    f.write("    if (rc != SQLITE_OK) {\n")
    f.write('        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));\n')
    f.write("    }\n\n")
    f.write("    int step = sqlite3_step(res);\n")

    f.write("    while(step != SQLITE_DONE && step != SQLITE_OK) {\n")
    f.write("        memset(&t, 0, sizeof(t));\n")
    f.write("        t.dirty = false;\n")
    f.write("        if (step == SQLITE_ROW) {\n")
    i = 0
    for x in v:
        name = x[0]
        _type = x[1]
        if _type == "INTEGER":
            f.write("        t." + name + " = sqlite3_column_int(res, " + str(i) + ");\n")
        elif _type == "REAL":
            f.write("        t." + name + " = sqlite3_column_double(res, " + str(i) + ");\n")
        elif _type == "TEXT":
            f.write("        char *_v" + str(i) +" = (char *)sqlite3_column_text(res, " + str(i) + ");\n")
            f.write("        if (_v" + str(i) + " != NULL) {\n")
            f.write("            t." + name + " = strdup(_v" + str(i) + ");\n")
            f.write("        }\n")

        i = i + 1
    f.write("        out.push_back(t);\n")
    f.write("        }\n")

    f.write("    step = sqlite3_step(res);\n")
    f.write("    }\n\n")

    f.write("    sqlite3_finalize(res);\n")
    f.write("    return out;\n")
    f.write("    }\n\n");

print "Generating cache_load_all"


f.write("cache_collection cache_load_all(bulkdata *b){\n")
f.write("    cache_collection out;\n")

for k, v in tables.iteritems():
    if v[0][1] != "INTEGER":
        print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
        continue
    f.write("    out.cache_" + k + " = " + k + "_load_all(b);\n")


f.write("    return out;\n")
f.write("};\n\n")

print "Generating ImGui edit windows"

for k, v in tables.iteritems():
    if v[0][1] != "INTEGER":
        print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
        continue
    f.write("void " + k + "_draw_edit(edit_window *e) {\n")
    f.write("    " + k + "*d = (" + k + "*)e->data;\n\n")

    f.write("    char title_buf[1024];\n")
    f.write('    snprintf(title_buf, 1024, "Editing object: %p", d);\n')
    f.write("    ImGui::Begin(title_buf, &e->show);\n")

    for x in v:
        name = x[0]
        _type = x[1]
        if _type == "INTEGER":
            f.write('    ImGui::InputInt("' + name + '", (int *)&d->' + name + ');\n')
        elif _type == "REAL":
            f.write('    ImGui::InputFloat("' + name + '", &d->' + name + ');\n')
        elif _type == "TEXT":
            f.write('    ImGui::Text("' + name + ':");\n')
            f.write('    ImGui::Text(d->' + name + ');\n')
        f.write('    ImGui::Separator();\n')


    f.write('    ImGui::End();\n')
    f.write("}\n\n")

for k, v in tables.iteritems():
    if v[0][1] != "INTEGER":
        print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
        continue
