# Don't look at this, thx

import sqlite3

def write_header(_f):
    _f.write("/* Generated by codegen.py\n")
    _f.write(" * DO NOT EDIT\n")
    _f.write(" */\n\n\n")

    

db = sqlite3.connect("bulkdata.db")

f = open("src/cache_types.h", "w")

write_header(f)
f.write('#include <stdio.h>\n\n')
f.write('#include "bulkdata.h"\n\n')

f.write("struct bulkdata;\n")


f.write("#ifndef __CACHE_TYPES__H__\n")
f.write("#define __CACHE_TYPES__H__\n\n")

cursor = db.cursor()
cursor.execute("SELECT * from sqlite_master WHERE type='table';")
tables = {}


for x in cursor.fetchall():
    schema = x[-1]
    schema = schema.split("(")[1]
    schema = schema.split(")")[0]
    schema = schema.split(",")
    schema = [c.strip(' ') for c in schema]
    n = []
    for b in schema:
       n.append((
           b.split(" ")[0],
           b.split(" ")[1]))
    schema = n
    tables[x[1]] = schema

for k, v in tables.iteritems():
    f.write("struct " + k + " {\n")

    for x in v:
        if x[1] == "INTEGER":
            f.write("    uint32_t ")
        if x[1] == "REAL":
            f.write("    float ")
        if x[1] == "TEXT":
            f.write("    char *")
        
        f.write(x[0]+ ";\n")

    f.write("};\n\n")

for k, v in tables.iteritems():
    if v[0][1] != "INTEGER":
        print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
        continue
    f.write(k + " " + k + "_load_by(bulkdata *b, uint32_t " + v[0][0] + ");\n")

f.write("#endif\n")

f.close()

f = open("src/cache_funcs.cpp", "w")
write_header(f)

f.write('#include "cache_types.h"\n\n')
f.write('#include <string.h>\n\n')
f.write('#include "bulkdata.h"\n\n')


for k, v in tables.iteritems():
    if v[0][1] != "INTEGER":
        print " >>>> WARN TABLE " + k + " IS NON INDEXABLE"
        continue
    f.write(k + " " + k + "_load_by(bulkdata *b, uint32_t " + v[0][0] + ") {\n")

    f.write("    char *err_msg = NULL;\n")
    f.write("    sqlite3_stmt *res;\n")


    f.write("    " + k + " t;\n")
    f.write("    memset(&t, 0, sizeof(t));\n")

    f.write('    char *stmt = (char *)"SELECT * from ' + k + ' where typeID = @id";\n');

    f.write("    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);\n");

    f.write("    if (rc == SQLITE_OK) {\n")
    f.write('        int idx = sqlite3_bind_parameter_index(res, "@id");\n')
    f.write('        sqlite3_bind_int(res, idx, ' + v[0][0] + ');\n')
    f.write("    } else {\n")
    f.write('        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));\n')
    f.write("    }\n\n")
    f.write("    int step = sqlite3_step(res);\n")

    f.write("    if (step == SQLITE_ROW) {\n")

    i = 0
    for x in v:
        name = x[0]
        _type = x[1]
        if _type == "INTEGER":
            f.write("        t." + name + " = sqlite3_column_int(res, " + str(i) + ");\n")
        elif _type == "REAL":
            f.write("        t." + name + " = sqlite3_column_double(res, " + str(i) + ");\n")
        elif _type == "TEXT":
            f.write("        t." + name + " = strdup((char *)sqlite3_column_text(res, " + str(i) + "));\n")
        i = i + 1
    f.write("    }\n\n");
    f.write("    sqlite3_finalize(res);\n")
    f.write("    return t;\n")
    f.write("}\n\n")








