/* Generated by codegen.py
 * DO NOT EDIT
 */


#include "cache_types.h"

#include <string.h>

#include "bulkdata.h"

#include <list>

#include "imgui.h"

#include "dogma-operand.h"

#include "images.h"

#include "ccp_stuff.h"

void cacheShipTypes_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheShipTypes*d = (cacheShipTypes*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("shipTypeID", (int *)&d->shipTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->shipTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->shipTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("weaponTypeID", (int *)&d->weaponTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->weaponTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->weaponTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("miningTypeID", (int *)&d->miningTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->miningTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->miningTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("skillTypeID", (int *)&d->skillTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->skillTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->skillTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheStaOperations_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheStaOperations*d = (cacheStaOperations*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("activityID", (int *)&d->activityID);
    ImGui::Separator();
    ImGui::InputInt("operationID", (int *)&d->operationID);
    ImGui::Separator();
    ImGui::Text("operationName:");
    ImGui::Text("%s", d->operationName);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("fringe", (int *)&d->fringe);
    ImGui::Separator();
    ImGui::InputInt("corridor", (int *)&d->corridor);
    ImGui::Separator();
    ImGui::InputInt("hub", (int *)&d->hub);
    ImGui::Separator();
    ImGui::InputInt("border", (int *)&d->border);
    ImGui::Separator();
    ImGui::InputInt("ratio", (int *)&d->ratio);
    ImGui::Separator();
    ImGui::InputInt("caldariStationTypeID", (int *)&d->caldariStationTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->caldariStationTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->caldariStationTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("minmatarStationTypeID", (int *)&d->minmatarStationTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->minmatarStationTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->minmatarStationTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("amarrStationTypeID", (int *)&d->amarrStationTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->amarrStationTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->amarrStationTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("gallenteStationTypeID", (int *)&d->gallenteStationTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->gallenteStationTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->gallenteStationTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("joveStationTypeID", (int *)&d->joveStationTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->joveStationTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->joveStationTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("operationNameID", (int *)&d->operationNameID);
    ImGui::Separator();
    ImGui::InputInt("descriptionID", (int *)&d->descriptionID);
    ImGui::Separator();
    ImGui::InputInt("serviceMask", (int *)&d->serviceMask);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheRamAssemblyLineTypesCategory_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheRamAssemblyLineTypesCategory*d = (cacheRamAssemblyLineTypesCategory*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("assemblyLineTypeID", (int *)&d->assemblyLineTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->assemblyLineTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->assemblyLineTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("categoryID", (int *)&d->categoryID);
    ImGui::Separator();
    ImGui::InputFloat("timeMultiplier", &d->timeMultiplier);
    ImGui::Separator();
    ImGui::InputFloat("materialMultiplier", &d->materialMultiplier);
    ImGui::Separator();
    ImGui::Text("activityID:");
    ImGui::Text("%s", d->activityID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheInvCategories_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheInvCategories*d = (cacheInvCategories*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("categoryID", (int *)&d->categoryID);
    ImGui::Separator();
    ImGui::Text("categoryName:");
    ImGui::Text("%s", d->categoryName);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("published", (int *)&d->published);
    ImGui::Separator();
    ImGui::InputInt("iconID", (int *)&d->iconID);
    ImGui::SameLine();
    ImGui::PushID(2000000 + d->iconID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheResIcons *tt = cache_get_cacheResIcons_by_iconID(cc, d->iconID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->iconID;
        w->show = true;
        w->tag = tag_cacheResIcons;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("categoryNameID", (int *)&d->categoryNameID);
    ImGui::Separator();
    ImGui::InputInt("dataID", (int *)&d->dataID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheDogmaEffects_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheDogmaEffects*d = (cacheDogmaEffects*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("effectID", (int *)&d->effectID);
    ImGui::Separator();
    ImGui::Text("effectName:");
    ImGui::Text("%s", d->effectName);
    ImGui::Separator();
    ImGui::InputInt("effectCategory", (int *)&d->effectCategory);
    ImGui::Separator();
    ImGui::InputInt("preExpression", (int *)&d->preExpression);
    ImGui::Separator();
    ImGui::InputInt("postExpression", (int *)&d->postExpression);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::Text("guid:");
    ImGui::Text("%s", d->guid);
    ImGui::Separator();
    ImGui::InputInt("isOffensive", (int *)&d->isOffensive);
    ImGui::Separator();
    ImGui::InputInt("isAssistance", (int *)&d->isAssistance);
    ImGui::Separator();
    ImGui::InputInt("durationAttributeID", (int *)&d->durationAttributeID);
    ImGui::Separator();
    ImGui::InputInt("trackingSpeedAttributeID", (int *)&d->trackingSpeedAttributeID);
    ImGui::Separator();
    ImGui::InputInt("dischargeAttributeID", (int *)&d->dischargeAttributeID);
    ImGui::Separator();
    ImGui::InputInt("rangeAttributeID", (int *)&d->rangeAttributeID);
    ImGui::Separator();
    ImGui::InputInt("falloffAttributeID", (int *)&d->falloffAttributeID);
    ImGui::Separator();
    ImGui::InputInt("disallowAutoRepeat", (int *)&d->disallowAutoRepeat);
    ImGui::Separator();
    ImGui::InputInt("published", (int *)&d->published);
    ImGui::Separator();
    ImGui::Text("displayName:");
    ImGui::Text("%s", d->displayName);
    ImGui::Separator();
    ImGui::InputInt("isWarpSafe", (int *)&d->isWarpSafe);
    ImGui::Separator();
    ImGui::InputInt("rangeChance", (int *)&d->rangeChance);
    ImGui::Separator();
    ImGui::InputInt("electronicChance", (int *)&d->electronicChance);
    ImGui::Separator();
    ImGui::InputInt("propulsionChance", (int *)&d->propulsionChance);
    ImGui::Separator();
    ImGui::InputInt("distribution", (int *)&d->distribution);
    ImGui::Separator();
    ImGui::Text("sfxName:");
    ImGui::Text("%s", d->sfxName);
    ImGui::Separator();
    ImGui::InputInt("npcUsageChanceAttributeID", (int *)&d->npcUsageChanceAttributeID);
    ImGui::Separator();
    ImGui::InputInt("npcActivationChanceAttributeID", (int *)&d->npcActivationChanceAttributeID);
    ImGui::Separator();
    ImGui::InputInt("fittingUsageChanceAttributeID", (int *)&d->fittingUsageChanceAttributeID);
    ImGui::Separator();
    ImGui::InputInt("iconID", (int *)&d->iconID);
    ImGui::SameLine();
    ImGui::PushID(2000000 + d->iconID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheResIcons *tt = cache_get_cacheResIcons_by_iconID(cc, d->iconID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->iconID;
        w->show = true;
        w->tag = tag_cacheResIcons;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("displayNameID", (int *)&d->displayNameID);
    ImGui::Separator();
    ImGui::InputInt("descriptionID", (int *)&d->descriptionID);
    ImGui::Separator();
    ImGui::InputInt("dataID", (int *)&d->dataID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheRamCompletedStatuses_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheRamCompletedStatuses*d = (cacheRamCompletedStatuses*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("completedStatus", (int *)&d->completedStatus);
    ImGui::Separator();
    ImGui::Text("completedStatusText:");
    ImGui::Text("%s", d->completedStatusText);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("completedStatusTextID", (int *)&d->completedStatusTextID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheInvBlueprintTypes_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheInvBlueprintTypes*d = (cacheInvBlueprintTypes*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("blueprintTypeID", (int *)&d->blueprintTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->blueprintTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->blueprintTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("parentBlueprintTypeID", (int *)&d->parentBlueprintTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->parentBlueprintTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->parentBlueprintTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("productTypeID", (int *)&d->productTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->productTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->productTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("productionTime", (int *)&d->productionTime);
    ImGui::Separator();
    ImGui::InputInt("techLevel", (int *)&d->techLevel);
    ImGui::Separator();
    ImGui::InputInt("researchProductivityTime", (int *)&d->researchProductivityTime);
    ImGui::Separator();
    ImGui::InputInt("researchMaterialTime", (int *)&d->researchMaterialTime);
    ImGui::Separator();
    ImGui::InputInt("researchCopyTime", (int *)&d->researchCopyTime);
    ImGui::Separator();
    ImGui::InputInt("researchTechTime", (int *)&d->researchTechTime);
    ImGui::Separator();
    ImGui::InputInt("productivityModifier", (int *)&d->productivityModifier);
    ImGui::Separator();
    ImGui::InputInt("materialModifier", (int *)&d->materialModifier);
    ImGui::Separator();
    ImGui::InputInt("wasteFactor", (int *)&d->wasteFactor);
    ImGui::Separator();
    ImGui::InputFloat("chanceOfReverseEngineering", &d->chanceOfReverseEngineering);
    ImGui::Separator();
    ImGui::InputInt("maxProductionLimit", (int *)&d->maxProductionLimit);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheRamTypeRequirements_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheRamTypeRequirements*d = (cacheRamTypeRequirements*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("typeID", (int *)&d->typeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->typeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->typeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("activityID", (int *)&d->activityID);
    ImGui::Separator();
    ImGui::InputInt("requiredTypeID", (int *)&d->requiredTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->requiredTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->requiredTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("quantity", (int *)&d->quantity);
    ImGui::Separator();
    ImGui::InputFloat("damagePerJob", &d->damagePerJob);
    ImGui::Separator();
    ImGui::InputInt("recycle", (int *)&d->recycle);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheCertificateRelationships_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheCertificateRelationships*d = (cacheCertificateRelationships*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("relationshipID", (int *)&d->relationshipID);
    ImGui::Separator();
    ImGui::InputInt("parentID", (int *)&d->parentID);
    ImGui::Separator();
    ImGui::InputInt("parentTypeID", (int *)&d->parentTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->parentTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->parentTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("parentLevel", (int *)&d->parentLevel);
    ImGui::Separator();
    ImGui::InputInt("childID", (int *)&d->childID);
    ImGui::Separator();
    ImGui::InputInt("childTypeID", (int *)&d->childTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->childTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->childTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheDogmaAttributes_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheDogmaAttributes*d = (cacheDogmaAttributes*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("attributeID", (int *)&d->attributeID);
    ImGui::Separator();
    ImGui::Text("attributeName:");
    ImGui::Text("%s", d->attributeName);
    ImGui::Separator();
    ImGui::InputInt("attributeCategory", (int *)&d->attributeCategory);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("maxAttributeID", (int *)&d->maxAttributeID);
    ImGui::Separator();
    ImGui::InputInt("attributeIdx", (int *)&d->attributeIdx);
    ImGui::Separator();
    ImGui::InputInt("chargeRechargeTimeID", (int *)&d->chargeRechargeTimeID);
    ImGui::Separator();
    ImGui::InputFloat("defaultValue", &d->defaultValue);
    ImGui::Separator();
    ImGui::InputInt("published", (int *)&d->published);
    ImGui::Separator();
    ImGui::Text("displayName:");
    ImGui::Text("%s", d->displayName);
    ImGui::Separator();
    ImGui::InputInt("unitID", (int *)&d->unitID);
    ImGui::Separator();
    ImGui::InputInt("stackable", (int *)&d->stackable);
    ImGui::Separator();
    ImGui::InputInt("highIsGood", (int *)&d->highIsGood);
    ImGui::Separator();
    ImGui::InputInt("categoryID", (int *)&d->categoryID);
    ImGui::Separator();
    ImGui::InputInt("iconID", (int *)&d->iconID);
    ImGui::SameLine();
    ImGui::PushID(2000000 + d->iconID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheResIcons *tt = cache_get_cacheResIcons_by_iconID(cc, d->iconID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->iconID;
        w->show = true;
        w->tag = tag_cacheResIcons;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("displayNameID", (int *)&d->displayNameID);
    ImGui::Separator();
    ImGui::InputInt("dataID", (int *)&d->dataID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheRamAssemblyLineTypes_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheRamAssemblyLineTypes*d = (cacheRamAssemblyLineTypes*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("assemblyLineTypeID", (int *)&d->assemblyLineTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->assemblyLineTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->assemblyLineTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::Text("assemblyLineTypeName:");
    ImGui::Text("%s", d->assemblyLineTypeName);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputFloat("baseTimeMultiplier", &d->baseTimeMultiplier);
    ImGui::Separator();
    ImGui::InputFloat("baseMaterialMultiplier", &d->baseMaterialMultiplier);
    ImGui::Separator();
    ImGui::InputFloat("volume", &d->volume);
    ImGui::Separator();
    ImGui::InputInt("activityID", (int *)&d->activityID);
    ImGui::Separator();
    ImGui::InputFloat("minCostPerHour", &d->minCostPerHour);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheStaStationsStatic_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheStaStationsStatic*d = (cacheStaStationsStatic*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("stationID", (int *)&d->stationID);
    ImGui::Separator();
    ImGui::Text("stationName:");
    ImGui::Text("%s", d->stationName);
    ImGui::Separator();
    ImGui::InputFloat("x", &d->x);
    ImGui::Separator();
    ImGui::InputFloat("y", &d->y);
    ImGui::Separator();
    ImGui::InputFloat("z", &d->z);
    ImGui::Separator();
    ImGui::InputInt("stationTypeID", (int *)&d->stationTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->stationTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->stationTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("solarSystemID", (int *)&d->solarSystemID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheInvGroups_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheInvGroups*d = (cacheInvGroups*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("groupID", (int *)&d->groupID);
    ImGui::Separator();
    ImGui::InputInt("categoryID", (int *)&d->categoryID);
    ImGui::Separator();
    ImGui::Text("groupName:");
    ImGui::Text("%s", d->groupName);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("useBasePrice", (int *)&d->useBasePrice);
    ImGui::Separator();
    ImGui::InputInt("allowManufacture", (int *)&d->allowManufacture);
    ImGui::Separator();
    ImGui::InputInt("allowRecycler", (int *)&d->allowRecycler);
    ImGui::Separator();
    ImGui::InputInt("anchored", (int *)&d->anchored);
    ImGui::Separator();
    ImGui::InputInt("anchorable", (int *)&d->anchorable);
    ImGui::Separator();
    ImGui::InputInt("fittableNonSingleton", (int *)&d->fittableNonSingleton);
    ImGui::Separator();
    ImGui::InputInt("published", (int *)&d->published);
    ImGui::Separator();
    ImGui::InputInt("iconID", (int *)&d->iconID);
    ImGui::SameLine();
    ImGui::PushID(2000000 + d->iconID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheResIcons *tt = cache_get_cacheResIcons_by_iconID(cc, d->iconID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->iconID;
        w->show = true;
        w->tag = tag_cacheResIcons;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("groupNameID", (int *)&d->groupNameID);
    ImGui::Separator();
    ImGui::InputInt("dataID", (int *)&d->dataID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheInvMetaTypes_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheInvMetaTypes*d = (cacheInvMetaTypes*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("typeID", (int *)&d->typeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->typeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->typeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("parentTypeID", (int *)&d->parentTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->parentTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->parentTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("metaGroupID", (int *)&d->metaGroupID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheInvTypeReactions_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheInvTypeReactions*d = (cacheInvTypeReactions*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("reactionTypeID", (int *)&d->reactionTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->reactionTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->reactionTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("input", (int *)&d->input);
    ImGui::Separator();
    ImGui::InputInt("typeID", (int *)&d->typeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->typeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->typeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("quantity", (int *)&d->quantity);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheDogmaTypeEffects_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheDogmaTypeEffects*d = (cacheDogmaTypeEffects*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("typeID", (int *)&d->typeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->typeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->typeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("effectID", (int *)&d->effectID);
    ImGui::Separator();
    ImGui::InputInt("isDefault", (int *)&d->isDefault);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cachePlanetSchematics_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cachePlanetSchematics*d = (cachePlanetSchematics*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("schematicID", (int *)&d->schematicID);
    ImGui::Separator();
    ImGui::Text("schematicName:");
    ImGui::Text("%s", d->schematicName);
    ImGui::Separator();
    ImGui::InputInt("cycleTime", (int *)&d->cycleTime);
    ImGui::Separator();
    ImGui::InputInt("schematicNameID", (int *)&d->schematicNameID);
    ImGui::Separator();
    ImGui::InputInt("dataID", (int *)&d->dataID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheDogmaUnits_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheDogmaUnits*d = (cacheDogmaUnits*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("unitID", (int *)&d->unitID);
    ImGui::Separator();
    ImGui::Text("unitName:");
    ImGui::Text("%s", d->unitName);
    ImGui::Separator();
    ImGui::Text("displayName:");
    ImGui::Text("%s", d->displayName);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("displayNameID", (int *)&d->displayNameID);
    ImGui::Separator();
    ImGui::InputInt("descriptionID", (int *)&d->descriptionID);
    ImGui::Separator();
    ImGui::InputInt("dataID", (int *)&d->dataID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cachePlanetSchematicsTypeMap_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cachePlanetSchematicsTypeMap*d = (cachePlanetSchematicsTypeMap*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("schematicID", (int *)&d->schematicID);
    ImGui::Separator();
    ImGui::InputInt("typeID", (int *)&d->typeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->typeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->typeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("isInput", (int *)&d->isInput);
    ImGui::Separator();
    ImGui::InputInt("quantity", (int *)&d->quantity);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheDogmaTypeAttributes_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheDogmaTypeAttributes*d = (cacheDogmaTypeAttributes*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("typeID", (int *)&d->typeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->typeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->typeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("attributeID", (int *)&d->attributeID);
    ImGui::Separator();
    ImGui::InputFloat("value", &d->value);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheDogmaExpressions_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheDogmaExpressions*d = (cacheDogmaExpressions*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("expressionID", (int *)&d->expressionID);
    ImGui::Separator();
    ImGui::InputInt("operandID", (int *)&d->operandID);
    ImGui::Text("%s", operand_id_strings[d->operandID]);
    ImGui::Separator();
    ImGui::InputInt("arg1", (int *)&d->arg1);
    ImGui::Separator();
    ImGui::InputInt("arg2", (int *)&d->arg2);
    ImGui::Separator();
    ImGui::Text("expressionValue:");
    ImGui::Text("%s", d->expressionValue);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::Text("expressionName:");
    ImGui::Text("%s", d->expressionName);
    ImGui::Separator();
    ImGui::InputInt("expressionTypeID", (int *)&d->expressionTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->expressionTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->expressionTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("expressionGroupID", (int *)&d->expressionGroupID);
    ImGui::Separator();
    ImGui::InputInt("expressionAttributeID", (int *)&d->expressionAttributeID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheRamAssemblyLineTypesGroup_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheRamAssemblyLineTypesGroup*d = (cacheRamAssemblyLineTypesGroup*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("assemblyLineTypeID", (int *)&d->assemblyLineTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->assemblyLineTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->assemblyLineTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("groupID", (int *)&d->groupID);
    ImGui::Separator();
    ImGui::InputFloat("timeMultiplier", &d->timeMultiplier);
    ImGui::Separator();
    ImGui::InputFloat("materialMultiplier", &d->materialMultiplier);
    ImGui::Separator();
    ImGui::Text("activityID:");
    ImGui::Text("%s", d->activityID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheResGraphics_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheResGraphics*d = (cacheResGraphics*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("graphicID", (int *)&d->graphicID);
    ImGui::Separator();
    ImGui::Text("graphicFile:");
    ImGui::Text("%s", d->graphicFile);
    ImGui::Separator();
    ImGui::Text("graphicName:");
    ImGui::Text("%s", d->graphicName);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("obsolete", (int *)&d->obsolete);
    ImGui::Separator();
    ImGui::Text("graphicType:");
    ImGui::Text("%s", d->graphicType);
    ImGui::Separator();
    ImGui::Text("collisionFile:");
    ImGui::Text("%s", d->collisionFile);
    ImGui::Separator();
    ImGui::Text("paperdollFile:");
    ImGui::Text("%s", d->paperdollFile);
    ImGui::Separator();
    ImGui::InputInt("animationTemplate", (int *)&d->animationTemplate);
    ImGui::Separator();
    ImGui::InputInt("collidable", (int *)&d->collidable);
    ImGui::Separator();
    ImGui::InputInt("explosionID", (int *)&d->explosionID);
    ImGui::Separator();
    ImGui::InputInt("directoryID", (int *)&d->directoryID);
    ImGui::Separator();
    ImGui::InputFloat("graphicMinX", &d->graphicMinX);
    ImGui::Separator();
    ImGui::InputFloat("graphicMinY", &d->graphicMinY);
    ImGui::Separator();
    ImGui::InputFloat("graphicMinZ", &d->graphicMinZ);
    ImGui::Separator();
    ImGui::InputFloat("graphicMaxX", &d->graphicMaxX);
    ImGui::Separator();
    ImGui::InputFloat("graphicMaxY", &d->graphicMaxY);
    ImGui::Separator();
    ImGui::InputFloat("graphicMaxZ", &d->graphicMaxZ);
    ImGui::Separator();
    ImGui::InputInt("isPrototype", (int *)&d->isPrototype);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheInvTypes_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheInvTypes*d = (cacheInvTypes*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("typeID", (int *)&d->typeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->typeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->typeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("groupID", (int *)&d->groupID);
    ImGui::Separator();
    ImGui::Text("typeName:");
    ImGui::Text("%s", d->typeName);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("graphicID", (int *)&d->graphicID);
    ImGui::Separator();
    ImGui::InputFloat("radius", &d->radius);
    ImGui::Separator();
    ImGui::InputFloat("mass", &d->mass);
    ImGui::Separator();
    ImGui::InputFloat("volume", &d->volume);
    ImGui::Separator();
    ImGui::InputFloat("capacity", &d->capacity);
    ImGui::Separator();
    ImGui::InputInt("portionSize", (int *)&d->portionSize);
    ImGui::Separator();
    ImGui::InputInt("raceID", (int *)&d->raceID);
    ImGui::Separator();
    ImGui::InputFloat("basePrice", &d->basePrice);
    ImGui::Separator();
    ImGui::InputInt("published", (int *)&d->published);
    ImGui::Separator();
    ImGui::InputInt("marketGroupID", (int *)&d->marketGroupID);
    ImGui::Separator();
    ImGui::InputFloat("chanceOfDuplicating", &d->chanceOfDuplicating);
    ImGui::Separator();
    ImGui::InputInt("soundID", (int *)&d->soundID);
    ImGui::Separator();
    ImGui::InputInt("iconID", (int *)&d->iconID);
    ImGui::SameLine();
    ImGui::PushID(2000000 + d->iconID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheResIcons *tt = cache_get_cacheResIcons_by_iconID(cc, d->iconID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->iconID;
        w->show = true;
        w->tag = tag_cacheResIcons;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("dataID", (int *)&d->dataID);
    ImGui::Separator();
    ImGui::InputInt("typeNameID", (int *)&d->typeNameID);
    ImGui::Separator();
    ImGui::InputInt("descriptionID", (int *)&d->descriptionID);
    ImGui::Separator();
    ImGui::InputInt("copyTypeID", (int *)&d->copyTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->copyTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->copyTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheResIcons_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheResIcons*d = (cacheResIcons*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("iconID", (int *)&d->iconID);
    ImGui::SameLine();
    ImGui::PushID(2000000 + d->iconID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheResIcons *tt = cache_get_cacheResIcons_by_iconID(cc, d->iconID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->iconID;
        w->show = true;
        w->tag = tag_cacheResIcons;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::Text("iconFile:");
    ImGui::Text("%s", d->iconFile);
    img_t img_cacheResIcons = load_or_get_img(d->iconFile);
    if (img_cacheResIcons.tex != 0) {        ImGui::Image((ImTextureID *)img_cacheResIcons.tex, ImVec2(img_cacheResIcons.width, img_cacheResIcons.height));
    }
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("obsolete", (int *)&d->obsolete);
    ImGui::Separator();
    ImGui::Text("iconType:");
    ImGui::Text("%s", d->iconType);
    ImGui::Separator();
    ImGui::InputInt("directoryID", (int *)&d->directoryID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheActBillTypes_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheActBillTypes*d = (cacheActBillTypes*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("billTypeID", (int *)&d->billTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->billTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->billTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::Text("billTypeName:");
    ImGui::Text("%s", d->billTypeName);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("billTypeNameID", (int *)&d->billTypeNameID);
    ImGui::Separator();
    ImGui::InputInt("dataID", (int *)&d->dataID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cachePlanetSchematicsPinMap_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cachePlanetSchematicsPinMap*d = (cachePlanetSchematicsPinMap*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("schematicID", (int *)&d->schematicID);
    ImGui::Separator();
    ImGui::InputInt("pinTypeID", (int *)&d->pinTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->pinTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->pinTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheInvContrabandTypes_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheInvContrabandTypes*d = (cacheInvContrabandTypes*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("factionID", (int *)&d->factionID);
    ImGui::Separator();
    ImGui::InputInt("typeID", (int *)&d->typeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->typeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->typeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputFloat("standingLoss", &d->standingLoss);
    ImGui::Separator();
    ImGui::InputFloat("confiscateMinSec", &d->confiscateMinSec);
    ImGui::Separator();
    ImGui::InputFloat("fineByValue", &d->fineByValue);
    ImGui::Separator();
    ImGui::InputFloat("attackMinSec", &d->attackMinSec);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheInvMetaGroups_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheInvMetaGroups*d = (cacheInvMetaGroups*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("metaGroupID", (int *)&d->metaGroupID);
    ImGui::Separator();
    ImGui::Text("metaGroupName:");
    ImGui::Text("%s", d->metaGroupName);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("iconID", (int *)&d->iconID);
    ImGui::SameLine();
    ImGui::PushID(2000000 + d->iconID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheResIcons *tt = cache_get_cacheResIcons_by_iconID(cc, d->iconID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->iconID;
        w->show = true;
        w->tag = tag_cacheResIcons;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("metaGroupNameID", (int *)&d->metaGroupNameID);
    ImGui::Separator();
    ImGui::InputInt("descriptionID", (int *)&d->descriptionID);
    ImGui::Separator();
    ImGui::InputInt("dataID", (int *)&d->dataID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheCertificates_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheCertificates*d = (cacheCertificates*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("certificateID", (int *)&d->certificateID);
    ImGui::Separator();
    ImGui::InputInt("categoryID", (int *)&d->categoryID);
    ImGui::Separator();
    ImGui::InputInt("classID", (int *)&d->classID);
    ImGui::Separator();
    ImGui::InputInt("grade", (int *)&d->grade);
    ImGui::Separator();
    ImGui::InputInt("corpID", (int *)&d->corpID);
    ImGui::Separator();
    ImGui::InputInt("iconID", (int *)&d->iconID);
    ImGui::SameLine();
    ImGui::PushID(2000000 + d->iconID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheResIcons *tt = cache_get_cacheResIcons_by_iconID(cc, d->iconID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->iconID;
        w->show = true;
        w->tag = tag_cacheResIcons;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("descriptionID", (int *)&d->descriptionID);
    ImGui::Separator();
    ImGui::InputInt("dataID", (int *)&d->dataID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheInvTypeMaterials_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheInvTypeMaterials*d = (cacheInvTypeMaterials*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("typeID", (int *)&d->typeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->typeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->typeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("materialTypeID", (int *)&d->materialTypeID);
    ImGui::SameLine();
    ImGui::PushID(1000000 + d->materialTypeID);
    if (ImGui::Button("Edit/Lookup")) {
        cacheInvTypes *tt = cache_get_cacheInvTypes_by_typeID(cc, d->materialTypeID);
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = tt;
        w->typeID = tt->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }
    ImGui::PopID();
    ImGui::Separator();
    ImGui::InputInt("quantity", (int *)&d->quantity);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheResSounds_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheResSounds*d = (cacheResSounds*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("soundID", (int *)&d->soundID);
    ImGui::Separator();
    ImGui::Text("soundFile:");
    ImGui::Text("%s", d->soundFile);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("obsolete", (int *)&d->obsolete);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void cacheRamActivities_draw_edit(std::list<edit_window *> *window_list, edit_window *e, cache_collection *cc) {
    cacheRamActivities*d = (cacheRamActivities*)e->data;

    char title_buf[1024];
    snprintf(title_buf, 1024, "Editing object: %p", d);
    ImGui::Begin(title_buf, &e->show);
    ImGui::InputInt("activityID", (int *)&d->activityID);
    ImGui::Separator();
    ImGui::Text("activityName:");
    ImGui::Text("%s", d->activityName);
    ImGui::Separator();
    ImGui::Text("iconNo:");
    ImGui::Text("%s", d->iconNo);
    ImGui::Separator();
    ImGui::Text("description:");
    ImGui::Text("%s", d->description);
    ImGui::Separator();
    ImGui::InputInt("published", (int *)&d->published);
    ImGui::Separator();
    ImGui::InputInt("activityNameID", (int *)&d->activityNameID);
    ImGui::Separator();
    ImGui::InputInt("descriptionID", (int *)&d->descriptionID);
    ImGui::Separator();
    ImGui::Checkbox("dirty", &d->dirty);
    if (ImGui::Button("Mark Dirty")) {
        d->dirty = true;
    }

    ImGui::End();
}

void draw_main_window() {
    bool tmp = true;    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheShipTypes")) {        sw.show_cacheShipTypes_search = !sw.show_cacheShipTypes_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheStaOperations")) {        sw.show_cacheStaOperations_search = !sw.show_cacheStaOperations_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheRamAssemblyLineTypesCategory")) {        sw.show_cacheRamAssemblyLineTypesCategory_search = !sw.show_cacheRamAssemblyLineTypesCategory_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheInvCategories")) {        sw.show_cacheInvCategories_search = !sw.show_cacheInvCategories_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheDogmaEffects")) {        sw.show_cacheDogmaEffects_search = !sw.show_cacheDogmaEffects_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheRamCompletedStatuses")) {        sw.show_cacheRamCompletedStatuses_search = !sw.show_cacheRamCompletedStatuses_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheInvBlueprintTypes")) {        sw.show_cacheInvBlueprintTypes_search = !sw.show_cacheInvBlueprintTypes_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheRamTypeRequirements")) {        sw.show_cacheRamTypeRequirements_search = !sw.show_cacheRamTypeRequirements_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheCertificateRelationships")) {        sw.show_cacheCertificateRelationships_search = !sw.show_cacheCertificateRelationships_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheDogmaAttributes")) {        sw.show_cacheDogmaAttributes_search = !sw.show_cacheDogmaAttributes_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheRamAssemblyLineTypes")) {        sw.show_cacheRamAssemblyLineTypes_search = !sw.show_cacheRamAssemblyLineTypes_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheStaStationsStatic")) {        sw.show_cacheStaStationsStatic_search = !sw.show_cacheStaStationsStatic_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheInvGroups")) {        sw.show_cacheInvGroups_search = !sw.show_cacheInvGroups_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheInvMetaTypes")) {        sw.show_cacheInvMetaTypes_search = !sw.show_cacheInvMetaTypes_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheInvTypeReactions")) {        sw.show_cacheInvTypeReactions_search = !sw.show_cacheInvTypeReactions_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheDogmaTypeEffects")) {        sw.show_cacheDogmaTypeEffects_search = !sw.show_cacheDogmaTypeEffects_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cachePlanetSchematics")) {        sw.show_cachePlanetSchematics_search = !sw.show_cachePlanetSchematics_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheDogmaUnits")) {        sw.show_cacheDogmaUnits_search = !sw.show_cacheDogmaUnits_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cachePlanetSchematicsTypeMap")) {        sw.show_cachePlanetSchematicsTypeMap_search = !sw.show_cachePlanetSchematicsTypeMap_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheDogmaTypeAttributes")) {        sw.show_cacheDogmaTypeAttributes_search = !sw.show_cacheDogmaTypeAttributes_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheDogmaExpressions")) {        sw.show_cacheDogmaExpressions_search = !sw.show_cacheDogmaExpressions_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheRamAssemblyLineTypesGroup")) {        sw.show_cacheRamAssemblyLineTypesGroup_search = !sw.show_cacheRamAssemblyLineTypesGroup_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheResGraphics")) {        sw.show_cacheResGraphics_search = !sw.show_cacheResGraphics_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheInvTypes")) {        sw.show_cacheInvTypes_search = !sw.show_cacheInvTypes_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheResIcons")) {        sw.show_cacheResIcons_search = !sw.show_cacheResIcons_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheActBillTypes")) {        sw.show_cacheActBillTypes_search = !sw.show_cacheActBillTypes_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cachePlanetSchematicsPinMap")) {        sw.show_cachePlanetSchematicsPinMap_search = !sw.show_cachePlanetSchematicsPinMap_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheInvContrabandTypes")) {        sw.show_cacheInvContrabandTypes_search = !sw.show_cacheInvContrabandTypes_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheInvMetaGroups")) {        sw.show_cacheInvMetaGroups_search = !sw.show_cacheInvMetaGroups_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheCertificates")) {        sw.show_cacheCertificates_search = !sw.show_cacheCertificates_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheInvTypeMaterials")) {        sw.show_cacheInvTypeMaterials_search = !sw.show_cacheInvTypeMaterials_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheResSounds")) {        sw.show_cacheResSounds_search = !sw.show_cacheResSounds_search;

    }

    ImGui::End();
    ImGui::Begin("Bulkdata recordsets", &tmp);
    if(ImGui::Button("Edit cacheRamActivities")) {        sw.show_cacheRamActivities_search = !sw.show_cacheRamActivities_search;

    }

    ImGui::End();
}

