/* Generated by codegen.py
 * DO NOT EDIT
 */


#include "cache_types.h"

#include <string.h>

#include "bulkdata.h"

#include <list>

#include "imgui.h"

void draw_search_window_cacheShipTypes(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheShipTypes *> results;
    ImGui::Begin("Search: cacheShipTypes");
    ImGui::InputText("cacheShipTypes", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheShipTypes.size(); i++) {
        cacheShipTypes *t = &cc->cache_cacheShipTypes[i];
    }

    for (uint32_t i = 0; i < cc->cache_cacheShipTypes.size(); i++) {
        results.push_back(&cc->cache_cacheShipTypes[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheShipTypes *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->shipTypeID;
        w->show = true;
        w->tag = tag_cacheShipTypes;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->shipTypeID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cacheStaOperations(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheStaOperations *> results;
    ImGui::Begin("Search: cacheStaOperations");
    ImGui::InputText("cacheStaOperations", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheStaOperations.size(); i++) {
        cacheStaOperations *t = &cc->cache_cacheStaOperations[i];
        if (t->operationName != NULL) {
        if (strstr(t->operationName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheStaOperations *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->activityID;
        w->show = true;
        w->tag = tag_cacheStaOperations;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->activityID, t->operationName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheRamAssemblyLineTypesCategory(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheRamAssemblyLineTypesCategory *> results;
    ImGui::Begin("Search: cacheRamAssemblyLineTypesCategory");
    ImGui::InputText("cacheRamAssemblyLineTypesCategory", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheRamAssemblyLineTypesCategory.size(); i++) {
        cacheRamAssemblyLineTypesCategory *t = &cc->cache_cacheRamAssemblyLineTypesCategory[i];
        if (t->activityID != NULL) {
        if (strstr(t->activityID, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheRamAssemblyLineTypesCategory *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->assemblyLineTypeID;
        w->show = true;
        w->tag = tag_cacheRamAssemblyLineTypesCategory;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->assemblyLineTypeID, t->activityID);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheInvCategories(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheInvCategories *> results;
    ImGui::Begin("Search: cacheInvCategories");
    ImGui::InputText("cacheInvCategories", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheInvCategories.size(); i++) {
        cacheInvCategories *t = &cc->cache_cacheInvCategories[i];
        if (t->categoryName != NULL) {
        if (strstr(t->categoryName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheInvCategories *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->categoryID;
        w->show = true;
        w->tag = tag_cacheInvCategories;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->categoryID, t->categoryName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheDogmaEffects(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheDogmaEffects *> results;
    ImGui::Begin("Search: cacheDogmaEffects");
    ImGui::InputText("cacheDogmaEffects", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheDogmaEffects.size(); i++) {
        cacheDogmaEffects *t = &cc->cache_cacheDogmaEffects[i];
        if (t->effectName != NULL) {
        if (strstr(t->effectName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->guid != NULL) {
        if (strstr(t->guid, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->displayName != NULL) {
        if (strstr(t->displayName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->sfxName != NULL) {
        if (strstr(t->sfxName, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheDogmaEffects *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->effectID;
        w->show = true;
        w->tag = tag_cacheDogmaEffects;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->effectID, t->effectName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheRamCompletedStatuses(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheRamCompletedStatuses *> results;
    ImGui::Begin("Search: cacheRamCompletedStatuses");
    ImGui::InputText("cacheRamCompletedStatuses", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheRamCompletedStatuses.size(); i++) {
        cacheRamCompletedStatuses *t = &cc->cache_cacheRamCompletedStatuses[i];
        if (t->completedStatusText != NULL) {
        if (strstr(t->completedStatusText, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheRamCompletedStatuses *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->completedStatus;
        w->show = true;
        w->tag = tag_cacheRamCompletedStatuses;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->completedStatus, t->completedStatusText);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheInvBlueprintTypes(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheInvBlueprintTypes *> results;
    ImGui::Begin("Search: cacheInvBlueprintTypes");
    ImGui::InputText("cacheInvBlueprintTypes", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheInvBlueprintTypes.size(); i++) {
        cacheInvBlueprintTypes *t = &cc->cache_cacheInvBlueprintTypes[i];
    }

    for (uint32_t i = 0; i < cc->cache_cacheInvBlueprintTypes.size(); i++) {
        results.push_back(&cc->cache_cacheInvBlueprintTypes[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheInvBlueprintTypes *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->blueprintTypeID;
        w->show = true;
        w->tag = tag_cacheInvBlueprintTypes;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->blueprintTypeID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cacheRamTypeRequirements(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheRamTypeRequirements *> results;
    ImGui::Begin("Search: cacheRamTypeRequirements");
    ImGui::InputText("cacheRamTypeRequirements", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheRamTypeRequirements.size(); i++) {
        cacheRamTypeRequirements *t = &cc->cache_cacheRamTypeRequirements[i];
    }

    for (uint32_t i = 0; i < cc->cache_cacheRamTypeRequirements.size(); i++) {
        results.push_back(&cc->cache_cacheRamTypeRequirements[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheRamTypeRequirements *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->typeID;
        w->show = true;
        w->tag = tag_cacheRamTypeRequirements;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->typeID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cacheCertificateRelationships(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheCertificateRelationships *> results;
    ImGui::Begin("Search: cacheCertificateRelationships");
    ImGui::InputText("cacheCertificateRelationships", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheCertificateRelationships.size(); i++) {
        cacheCertificateRelationships *t = &cc->cache_cacheCertificateRelationships[i];
    }

    for (uint32_t i = 0; i < cc->cache_cacheCertificateRelationships.size(); i++) {
        results.push_back(&cc->cache_cacheCertificateRelationships[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheCertificateRelationships *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->relationshipID;
        w->show = true;
        w->tag = tag_cacheCertificateRelationships;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->relationshipID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cacheDogmaAttributes(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheDogmaAttributes *> results;
    ImGui::Begin("Search: cacheDogmaAttributes");
    ImGui::InputText("cacheDogmaAttributes", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheDogmaAttributes.size(); i++) {
        cacheDogmaAttributes *t = &cc->cache_cacheDogmaAttributes[i];
        if (t->attributeName != NULL) {
        if (strstr(t->attributeName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->displayName != NULL) {
        if (strstr(t->displayName, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheDogmaAttributes *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->attributeID;
        w->show = true;
        w->tag = tag_cacheDogmaAttributes;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->attributeID, t->attributeName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheRamAssemblyLineTypes(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheRamAssemblyLineTypes *> results;
    ImGui::Begin("Search: cacheRamAssemblyLineTypes");
    ImGui::InputText("cacheRamAssemblyLineTypes", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheRamAssemblyLineTypes.size(); i++) {
        cacheRamAssemblyLineTypes *t = &cc->cache_cacheRamAssemblyLineTypes[i];
        if (t->assemblyLineTypeName != NULL) {
        if (strstr(t->assemblyLineTypeName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheRamAssemblyLineTypes *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->assemblyLineTypeID;
        w->show = true;
        w->tag = tag_cacheRamAssemblyLineTypes;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->assemblyLineTypeID, t->assemblyLineTypeName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheStaStationsStatic(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheStaStationsStatic *> results;
    ImGui::Begin("Search: cacheStaStationsStatic");
    ImGui::InputText("cacheStaStationsStatic", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheStaStationsStatic.size(); i++) {
        cacheStaStationsStatic *t = &cc->cache_cacheStaStationsStatic[i];
        if (t->stationName != NULL) {
        if (strstr(t->stationName, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheStaStationsStatic *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->stationID;
        w->show = true;
        w->tag = tag_cacheStaStationsStatic;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->stationID, t->stationName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheInvGroups(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheInvGroups *> results;
    ImGui::Begin("Search: cacheInvGroups");
    ImGui::InputText("cacheInvGroups", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheInvGroups.size(); i++) {
        cacheInvGroups *t = &cc->cache_cacheInvGroups[i];
        if (t->groupName != NULL) {
        if (strstr(t->groupName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheInvGroups *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->groupID;
        w->show = true;
        w->tag = tag_cacheInvGroups;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->groupID, t->groupName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheInvMetaTypes(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheInvMetaTypes *> results;
    ImGui::Begin("Search: cacheInvMetaTypes");
    ImGui::InputText("cacheInvMetaTypes", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheInvMetaTypes.size(); i++) {
        cacheInvMetaTypes *t = &cc->cache_cacheInvMetaTypes[i];
    }

    for (uint32_t i = 0; i < cc->cache_cacheInvMetaTypes.size(); i++) {
        results.push_back(&cc->cache_cacheInvMetaTypes[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheInvMetaTypes *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->typeID;
        w->show = true;
        w->tag = tag_cacheInvMetaTypes;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->typeID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cacheInvTypeReactions(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheInvTypeReactions *> results;
    ImGui::Begin("Search: cacheInvTypeReactions");
    ImGui::InputText("cacheInvTypeReactions", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheInvTypeReactions.size(); i++) {
        cacheInvTypeReactions *t = &cc->cache_cacheInvTypeReactions[i];
    }

    for (uint32_t i = 0; i < cc->cache_cacheInvTypeReactions.size(); i++) {
        results.push_back(&cc->cache_cacheInvTypeReactions[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheInvTypeReactions *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->reactionTypeID;
        w->show = true;
        w->tag = tag_cacheInvTypeReactions;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->reactionTypeID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cacheDogmaTypeEffects(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheDogmaTypeEffects *> results;
    ImGui::Begin("Search: cacheDogmaTypeEffects");
    ImGui::InputText("cacheDogmaTypeEffects", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheDogmaTypeEffects.size(); i++) {
        cacheDogmaTypeEffects *t = &cc->cache_cacheDogmaTypeEffects[i];
    }

    for (uint32_t i = 0; i < cc->cache_cacheDogmaTypeEffects.size(); i++) {
        results.push_back(&cc->cache_cacheDogmaTypeEffects[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheDogmaTypeEffects *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->typeID;
        w->show = true;
        w->tag = tag_cacheDogmaTypeEffects;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->typeID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cachePlanetSchematics(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cachePlanetSchematics *> results;
    ImGui::Begin("Search: cachePlanetSchematics");
    ImGui::InputText("cachePlanetSchematics", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cachePlanetSchematics.size(); i++) {
        cachePlanetSchematics *t = &cc->cache_cachePlanetSchematics[i];
        if (t->schematicName != NULL) {
        if (strstr(t->schematicName, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cachePlanetSchematics *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->schematicID;
        w->show = true;
        w->tag = tag_cachePlanetSchematics;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->schematicID, t->schematicName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheDogmaUnits(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheDogmaUnits *> results;
    ImGui::Begin("Search: cacheDogmaUnits");
    ImGui::InputText("cacheDogmaUnits", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheDogmaUnits.size(); i++) {
        cacheDogmaUnits *t = &cc->cache_cacheDogmaUnits[i];
        if (t->unitName != NULL) {
        if (strstr(t->unitName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->displayName != NULL) {
        if (strstr(t->displayName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheDogmaUnits *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->unitID;
        w->show = true;
        w->tag = tag_cacheDogmaUnits;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->unitID, t->unitName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cachePlanetSchematicsTypeMap(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cachePlanetSchematicsTypeMap *> results;
    ImGui::Begin("Search: cachePlanetSchematicsTypeMap");
    ImGui::InputText("cachePlanetSchematicsTypeMap", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cachePlanetSchematicsTypeMap.size(); i++) {
        cachePlanetSchematicsTypeMap *t = &cc->cache_cachePlanetSchematicsTypeMap[i];
    }

    for (uint32_t i = 0; i < cc->cache_cachePlanetSchematicsTypeMap.size(); i++) {
        results.push_back(&cc->cache_cachePlanetSchematicsTypeMap[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cachePlanetSchematicsTypeMap *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->schematicID;
        w->show = true;
        w->tag = tag_cachePlanetSchematicsTypeMap;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->schematicID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cacheDogmaTypeAttributes(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheDogmaTypeAttributes *> results;
    ImGui::Begin("Search: cacheDogmaTypeAttributes");
    ImGui::InputText("cacheDogmaTypeAttributes", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheDogmaTypeAttributes.size(); i++) {
        cacheDogmaTypeAttributes *t = &cc->cache_cacheDogmaTypeAttributes[i];
    }

    for (uint32_t i = 0; i < cc->cache_cacheDogmaTypeAttributes.size(); i++) {
        results.push_back(&cc->cache_cacheDogmaTypeAttributes[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheDogmaTypeAttributes *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->typeID;
        w->show = true;
        w->tag = tag_cacheDogmaTypeAttributes;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->typeID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cacheDogmaExpressions(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheDogmaExpressions *> results;
    ImGui::Begin("Search: cacheDogmaExpressions");
    ImGui::InputText("cacheDogmaExpressions", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheDogmaExpressions.size(); i++) {
        cacheDogmaExpressions *t = &cc->cache_cacheDogmaExpressions[i];
        if (t->expressionValue != NULL) {
        if (strstr(t->expressionValue, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->expressionName != NULL) {
        if (strstr(t->expressionName, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheDogmaExpressions *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->expressionID;
        w->show = true;
        w->tag = tag_cacheDogmaExpressions;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->expressionID, t->expressionValue);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheRamAssemblyLineTypesGroup(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheRamAssemblyLineTypesGroup *> results;
    ImGui::Begin("Search: cacheRamAssemblyLineTypesGroup");
    ImGui::InputText("cacheRamAssemblyLineTypesGroup", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheRamAssemblyLineTypesGroup.size(); i++) {
        cacheRamAssemblyLineTypesGroup *t = &cc->cache_cacheRamAssemblyLineTypesGroup[i];
        if (t->activityID != NULL) {
        if (strstr(t->activityID, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheRamAssemblyLineTypesGroup *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->assemblyLineTypeID;
        w->show = true;
        w->tag = tag_cacheRamAssemblyLineTypesGroup;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->assemblyLineTypeID, t->activityID);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheResGraphics(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheResGraphics *> results;
    ImGui::Begin("Search: cacheResGraphics");
    ImGui::InputText("cacheResGraphics", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheResGraphics.size(); i++) {
        cacheResGraphics *t = &cc->cache_cacheResGraphics[i];
        if (t->graphicFile != NULL) {
        if (strstr(t->graphicFile, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->graphicName != NULL) {
        if (strstr(t->graphicName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->graphicType != NULL) {
        if (strstr(t->graphicType, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->collisionFile != NULL) {
        if (strstr(t->collisionFile, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->paperdollFile != NULL) {
        if (strstr(t->paperdollFile, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheResGraphics *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->graphicID;
        w->show = true;
        w->tag = tag_cacheResGraphics;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->graphicID, t->graphicFile);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheInvTypes(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheInvTypes *> results;
    ImGui::Begin("Search: cacheInvTypes");
    ImGui::InputText("cacheInvTypes", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheInvTypes.size(); i++) {
        cacheInvTypes *t = &cc->cache_cacheInvTypes[i];
        if (t->typeName != NULL) {
        if (strstr(t->typeName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheInvTypes *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypes;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->typeID, t->typeName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheResIcons(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheResIcons *> results;
    ImGui::Begin("Search: cacheResIcons");
    ImGui::InputText("cacheResIcons", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheResIcons.size(); i++) {
        cacheResIcons *t = &cc->cache_cacheResIcons[i];
        if (t->iconFile != NULL) {
        if (strstr(t->iconFile, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->iconType != NULL) {
        if (strstr(t->iconType, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheResIcons *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->iconID;
        w->show = true;
        w->tag = tag_cacheResIcons;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->iconID, t->iconFile);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheActBillTypes(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheActBillTypes *> results;
    ImGui::Begin("Search: cacheActBillTypes");
    ImGui::InputText("cacheActBillTypes", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheActBillTypes.size(); i++) {
        cacheActBillTypes *t = &cc->cache_cacheActBillTypes[i];
        if (t->billTypeName != NULL) {
        if (strstr(t->billTypeName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheActBillTypes *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->billTypeID;
        w->show = true;
        w->tag = tag_cacheActBillTypes;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->billTypeID, t->billTypeName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cachePlanetSchematicsPinMap(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cachePlanetSchematicsPinMap *> results;
    ImGui::Begin("Search: cachePlanetSchematicsPinMap");
    ImGui::InputText("cachePlanetSchematicsPinMap", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cachePlanetSchematicsPinMap.size(); i++) {
        cachePlanetSchematicsPinMap *t = &cc->cache_cachePlanetSchematicsPinMap[i];
    }

    for (uint32_t i = 0; i < cc->cache_cachePlanetSchematicsPinMap.size(); i++) {
        results.push_back(&cc->cache_cachePlanetSchematicsPinMap[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cachePlanetSchematicsPinMap *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->schematicID;
        w->show = true;
        w->tag = tag_cachePlanetSchematicsPinMap;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->schematicID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cacheInvContrabandTypes(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheInvContrabandTypes *> results;
    ImGui::Begin("Search: cacheInvContrabandTypes");
    ImGui::InputText("cacheInvContrabandTypes", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheInvContrabandTypes.size(); i++) {
        cacheInvContrabandTypes *t = &cc->cache_cacheInvContrabandTypes[i];
    }

    for (uint32_t i = 0; i < cc->cache_cacheInvContrabandTypes.size(); i++) {
        results.push_back(&cc->cache_cacheInvContrabandTypes[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheInvContrabandTypes *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->factionID;
        w->show = true;
        w->tag = tag_cacheInvContrabandTypes;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->factionID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cacheInvMetaGroups(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheInvMetaGroups *> results;
    ImGui::Begin("Search: cacheInvMetaGroups");
    ImGui::InputText("cacheInvMetaGroups", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheInvMetaGroups.size(); i++) {
        cacheInvMetaGroups *t = &cc->cache_cacheInvMetaGroups[i];
        if (t->metaGroupName != NULL) {
        if (strstr(t->metaGroupName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheInvMetaGroups *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->metaGroupID;
        w->show = true;
        w->tag = tag_cacheInvMetaGroups;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->metaGroupID, t->metaGroupName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheCertificates(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheCertificates *> results;
    ImGui::Begin("Search: cacheCertificates");
    ImGui::InputText("cacheCertificates", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheCertificates.size(); i++) {
        cacheCertificates *t = &cc->cache_cacheCertificates[i];
        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheCertificates *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->certificateID;
        w->show = true;
        w->tag = tag_cacheCertificates;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->certificateID, t->description);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheInvTypeMaterials(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheInvTypeMaterials *> results;
    ImGui::Begin("Search: cacheInvTypeMaterials");
    ImGui::InputText("cacheInvTypeMaterials", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheInvTypeMaterials.size(); i++) {
        cacheInvTypeMaterials *t = &cc->cache_cacheInvTypeMaterials[i];
    }

    for (uint32_t i = 0; i < cc->cache_cacheInvTypeMaterials.size(); i++) {
        results.push_back(&cc->cache_cacheInvTypeMaterials[i]);
    }
    ImGui::Text("This recordset is not searchable");
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheInvTypeMaterials *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->typeID;
        w->show = true;
        w->tag = tag_cacheInvTypeMaterials;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] <no name>", t->typeID);
    ImGui::PopID();
    }
    }
    ImGui::End();
}

void draw_search_window_cacheResSounds(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheResSounds *> results;
    ImGui::Begin("Search: cacheResSounds");
    ImGui::InputText("cacheResSounds", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheResSounds.size(); i++) {
        cacheResSounds *t = &cc->cache_cacheResSounds[i];
        if (t->soundFile != NULL) {
        if (strstr(t->soundFile, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheResSounds *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->soundID;
        w->show = true;
        w->tag = tag_cacheResSounds;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->soundID, t->soundFile);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_window_cacheRamActivities(cache_collection *cc, std::list<edit_window *> *window_list) {
    static char buffer[1024];
    std::vector<cacheRamActivities *> results;
    ImGui::Begin("Search: cacheRamActivities");
    ImGui::InputText("cacheRamActivities", buffer, 1024);
    if (strcmp(buffer, "") != 0) {

    for (uint32_t i = 0; i < cc->cache_cacheRamActivities.size(); i++) {
        cacheRamActivities *t = &cc->cache_cacheRamActivities[i];
        if (t->activityName != NULL) {
        if (strstr(t->activityName, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->iconNo != NULL) {
        if (strstr(t->iconNo, buffer) != NULL) {
        results.push_back(t);
        }

        }

        if (t->description != NULL) {
        if (strstr(t->description, buffer) != NULL) {
        results.push_back(t);
        }

        }

    }

    ImGui::Text("Results: %d", results.size());
    ImGui::Separator();

    for (uint32_t i = 0; i < results.size(); i++) {
        cacheRamActivities *t = results[i];    ImGui::PushID(i);
    if (ImGui::Button("Edit")) {
        printf("Opening window\n");
        edit_window *w = (edit_window *)calloc(1, sizeof(edit_window));
        w->data = t;
        w->typeID = t->activityID;
        w->show = true;
        w->tag = tag_cacheRamActivities;
        window_list->push_back(w);
    }

    ImGui::SameLine();
    ImGui::Text("[%d] %s", t->activityID, t->activityName);
    ImGui::PopID();
    ImGui::Separator();

    }
    }
    ImGui::End();
}

void draw_search_windows(cache_collection *cc, std::list<edit_window *> *window_list) {
    if (sw.show_cacheShipTypes_search) {
        draw_search_window_cacheShipTypes(cc, window_list);    }

    if (sw.show_cacheStaOperations_search) {
        draw_search_window_cacheStaOperations(cc, window_list);    }

    if (sw.show_cacheRamAssemblyLineTypesCategory_search) {
        draw_search_window_cacheRamAssemblyLineTypesCategory(cc, window_list);    }

    if (sw.show_cacheInvCategories_search) {
        draw_search_window_cacheInvCategories(cc, window_list);    }

    if (sw.show_cacheDogmaEffects_search) {
        draw_search_window_cacheDogmaEffects(cc, window_list);    }

    if (sw.show_cacheRamCompletedStatuses_search) {
        draw_search_window_cacheRamCompletedStatuses(cc, window_list);    }

    if (sw.show_cacheInvBlueprintTypes_search) {
        draw_search_window_cacheInvBlueprintTypes(cc, window_list);    }

    if (sw.show_cacheRamTypeRequirements_search) {
        draw_search_window_cacheRamTypeRequirements(cc, window_list);    }

    if (sw.show_cacheCertificateRelationships_search) {
        draw_search_window_cacheCertificateRelationships(cc, window_list);    }

    if (sw.show_cacheDogmaAttributes_search) {
        draw_search_window_cacheDogmaAttributes(cc, window_list);    }

    if (sw.show_cacheRamAssemblyLineTypes_search) {
        draw_search_window_cacheRamAssemblyLineTypes(cc, window_list);    }

    if (sw.show_cacheStaStationsStatic_search) {
        draw_search_window_cacheStaStationsStatic(cc, window_list);    }

    if (sw.show_cacheInvGroups_search) {
        draw_search_window_cacheInvGroups(cc, window_list);    }

    if (sw.show_cacheInvMetaTypes_search) {
        draw_search_window_cacheInvMetaTypes(cc, window_list);    }

    if (sw.show_cacheInvTypeReactions_search) {
        draw_search_window_cacheInvTypeReactions(cc, window_list);    }

    if (sw.show_cacheDogmaTypeEffects_search) {
        draw_search_window_cacheDogmaTypeEffects(cc, window_list);    }

    if (sw.show_cachePlanetSchematics_search) {
        draw_search_window_cachePlanetSchematics(cc, window_list);    }

    if (sw.show_cacheDogmaUnits_search) {
        draw_search_window_cacheDogmaUnits(cc, window_list);    }

    if (sw.show_cachePlanetSchematicsTypeMap_search) {
        draw_search_window_cachePlanetSchematicsTypeMap(cc, window_list);    }

    if (sw.show_cacheDogmaTypeAttributes_search) {
        draw_search_window_cacheDogmaTypeAttributes(cc, window_list);    }

    if (sw.show_cacheDogmaExpressions_search) {
        draw_search_window_cacheDogmaExpressions(cc, window_list);    }

    if (sw.show_cacheRamAssemblyLineTypesGroup_search) {
        draw_search_window_cacheRamAssemblyLineTypesGroup(cc, window_list);    }

    if (sw.show_cacheResGraphics_search) {
        draw_search_window_cacheResGraphics(cc, window_list);    }

    if (sw.show_cacheInvTypes_search) {
        draw_search_window_cacheInvTypes(cc, window_list);    }

    if (sw.show_cacheResIcons_search) {
        draw_search_window_cacheResIcons(cc, window_list);    }

    if (sw.show_cacheActBillTypes_search) {
        draw_search_window_cacheActBillTypes(cc, window_list);    }

    if (sw.show_cachePlanetSchematicsPinMap_search) {
        draw_search_window_cachePlanetSchematicsPinMap(cc, window_list);    }

    if (sw.show_cacheInvContrabandTypes_search) {
        draw_search_window_cacheInvContrabandTypes(cc, window_list);    }

    if (sw.show_cacheInvMetaGroups_search) {
        draw_search_window_cacheInvMetaGroups(cc, window_list);    }

    if (sw.show_cacheCertificates_search) {
        draw_search_window_cacheCertificates(cc, window_list);    }

    if (sw.show_cacheInvTypeMaterials_search) {
        draw_search_window_cacheInvTypeMaterials(cc, window_list);    }

    if (sw.show_cacheResSounds_search) {
        draw_search_window_cacheResSounds(cc, window_list);    }

    if (sw.show_cacheRamActivities_search) {
        draw_search_window_cacheRamActivities(cc, window_list);    }

}

void window_list_draw(std::list<edit_window *> *window_list, cache_collection *cc) {
for (auto it = window_list->begin(); it != window_list->end(); it++) {
    edit_window *w = *it;
    if (w->show == false) {
        it = window_list->erase(it);
        printf("Closing edit window\n");        continue;    }

    switch (w->tag) {    case tag_cacheShipTypes: {
        cacheShipTypes_draw_edit(window_list, w, cc);
    } break;    case tag_cacheStaOperations: {
        cacheStaOperations_draw_edit(window_list, w, cc);
    } break;    case tag_cacheRamAssemblyLineTypesCategory: {
        cacheRamAssemblyLineTypesCategory_draw_edit(window_list, w, cc);
    } break;    case tag_cacheInvCategories: {
        cacheInvCategories_draw_edit(window_list, w, cc);
    } break;    case tag_cacheDogmaEffects: {
        cacheDogmaEffects_draw_edit(window_list, w, cc);
    } break;    case tag_cacheRamCompletedStatuses: {
        cacheRamCompletedStatuses_draw_edit(window_list, w, cc);
    } break;    case tag_cacheInvBlueprintTypes: {
        cacheInvBlueprintTypes_draw_edit(window_list, w, cc);
    } break;    case tag_cacheRamTypeRequirements: {
        cacheRamTypeRequirements_draw_edit(window_list, w, cc);
    } break;    case tag_cacheCertificateRelationships: {
        cacheCertificateRelationships_draw_edit(window_list, w, cc);
    } break;    case tag_cacheDogmaAttributes: {
        cacheDogmaAttributes_draw_edit(window_list, w, cc);
    } break;    case tag_cacheRamAssemblyLineTypes: {
        cacheRamAssemblyLineTypes_draw_edit(window_list, w, cc);
    } break;    case tag_cacheStaStationsStatic: {
        cacheStaStationsStatic_draw_edit(window_list, w, cc);
    } break;    case tag_cacheInvGroups: {
        cacheInvGroups_draw_edit(window_list, w, cc);
    } break;    case tag_cacheInvMetaTypes: {
        cacheInvMetaTypes_draw_edit(window_list, w, cc);
    } break;    case tag_cacheInvTypeReactions: {
        cacheInvTypeReactions_draw_edit(window_list, w, cc);
    } break;    case tag_cacheDogmaTypeEffects: {
        cacheDogmaTypeEffects_draw_edit(window_list, w, cc);
    } break;    case tag_cachePlanetSchematics: {
        cachePlanetSchematics_draw_edit(window_list, w, cc);
    } break;    case tag_cacheDogmaUnits: {
        cacheDogmaUnits_draw_edit(window_list, w, cc);
    } break;    case tag_cachePlanetSchematicsTypeMap: {
        cachePlanetSchematicsTypeMap_draw_edit(window_list, w, cc);
    } break;    case tag_cacheDogmaTypeAttributes: {
        cacheDogmaTypeAttributes_draw_edit(window_list, w, cc);
    } break;    case tag_cacheDogmaExpressions: {
        cacheDogmaExpressions_draw_edit(window_list, w, cc);
    } break;    case tag_cacheRamAssemblyLineTypesGroup: {
        cacheRamAssemblyLineTypesGroup_draw_edit(window_list, w, cc);
    } break;    case tag_cacheResGraphics: {
        cacheResGraphics_draw_edit(window_list, w, cc);
    } break;    case tag_cacheInvTypes: {
        cacheInvTypes_draw_edit(window_list, w, cc);
    } break;    case tag_cacheResIcons: {
        cacheResIcons_draw_edit(window_list, w, cc);
    } break;    case tag_cacheActBillTypes: {
        cacheActBillTypes_draw_edit(window_list, w, cc);
    } break;    case tag_cachePlanetSchematicsPinMap: {
        cachePlanetSchematicsPinMap_draw_edit(window_list, w, cc);
    } break;    case tag_cacheInvContrabandTypes: {
        cacheInvContrabandTypes_draw_edit(window_list, w, cc);
    } break;    case tag_cacheInvMetaGroups: {
        cacheInvMetaGroups_draw_edit(window_list, w, cc);
    } break;    case tag_cacheCertificates: {
        cacheCertificates_draw_edit(window_list, w, cc);
    } break;    case tag_cacheInvTypeMaterials: {
        cacheInvTypeMaterials_draw_edit(window_list, w, cc);
    } break;    case tag_cacheResSounds: {
        cacheResSounds_draw_edit(window_list, w, cc);
    } break;    case tag_cacheRamActivities: {
        cacheRamActivities_draw_edit(window_list, w, cc);
    } break;    }

}

}

