/* Generated by codegen.py
 * DO NOT EDIT
 */


#include "cache_types.h"

#include <string.h>

#include "bulkdata.h"

#include <list>

#include "imgui.h"

search_windows sw;

cacheShipTypes cacheShipTypes_load_by(bulkdata *b, uint32_t shipTypeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheShipTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheShipTypes where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, shipTypeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.shipTypeID = sqlite3_column_int(res, 0);
        t.weaponTypeID = sqlite3_column_int(res, 1);
        t.miningTypeID = sqlite3_column_int(res, 2);
        t.skillTypeID = sqlite3_column_int(res, 3);
    }

    sqlite3_finalize(res);
    return t;
}

cacheStaOperations cacheStaOperations_load_by(bulkdata *b, uint32_t activityID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheStaOperations t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheStaOperations where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, activityID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.activityID = sqlite3_column_int(res, 0);
        t.operationID = sqlite3_column_int(res, 1);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.operationName = strdup(_v2);
        }
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        }
        t.fringe = sqlite3_column_int(res, 4);
        t.corridor = sqlite3_column_int(res, 5);
        t.hub = sqlite3_column_int(res, 6);
        t.border = sqlite3_column_int(res, 7);
        t.ratio = sqlite3_column_int(res, 8);
        t.caldariStationTypeID = sqlite3_column_int(res, 9);
        t.minmatarStationTypeID = sqlite3_column_int(res, 10);
        t.amarrStationTypeID = sqlite3_column_int(res, 11);
        t.gallenteStationTypeID = sqlite3_column_int(res, 12);
        t.joveStationTypeID = sqlite3_column_int(res, 13);
        t.operationNameID = sqlite3_column_int(res, 14);
        t.descriptionID = sqlite3_column_int(res, 15);
        t.serviceMask = sqlite3_column_int(res, 16);
    }

    sqlite3_finalize(res);
    return t;
}

cacheRamAssemblyLineTypesCategory cacheRamAssemblyLineTypesCategory_load_by(bulkdata *b, uint32_t assemblyLineTypeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheRamAssemblyLineTypesCategory t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamAssemblyLineTypesCategory where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, assemblyLineTypeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.assemblyLineTypeID = sqlite3_column_int(res, 0);
        t.categoryID = sqlite3_column_int(res, 1);
        t.timeMultiplier = sqlite3_column_double(res, 2);
        t.materialMultiplier = sqlite3_column_double(res, 3);
        char *_v4 = (char *)sqlite3_column_text(res, 4);
        if (_v4 != NULL) {
            t.activityID = strdup(_v4);
        }
    }

    sqlite3_finalize(res);
    return t;
}

cacheInvCategories cacheInvCategories_load_by(bulkdata *b, uint32_t categoryID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheInvCategories t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvCategories where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, categoryID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.categoryID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.categoryName = strdup(_v1);
        }
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        }
        t.published = sqlite3_column_int(res, 3);
        t.iconID = sqlite3_column_int(res, 4);
        t.categoryNameID = sqlite3_column_int(res, 5);
        t.dataID = sqlite3_column_int(res, 6);
    }

    sqlite3_finalize(res);
    return t;
}

cacheDogmaEffects cacheDogmaEffects_load_by(bulkdata *b, uint32_t effectID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheDogmaEffects t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaEffects where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, effectID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.effectID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.effectName = strdup(_v1);
        }
        t.effectCategory = sqlite3_column_int(res, 2);
        t.preExpression = sqlite3_column_int(res, 3);
        t.postExpression = sqlite3_column_int(res, 4);
        char *_v5 = (char *)sqlite3_column_text(res, 5);
        if (_v5 != NULL) {
            t.description = strdup(_v5);
        }
        char *_v6 = (char *)sqlite3_column_text(res, 6);
        if (_v6 != NULL) {
            t.guid = strdup(_v6);
        }
        t.isOffensive = sqlite3_column_int(res, 7);
        t.isAssistance = sqlite3_column_int(res, 8);
        t.durationAttributeID = sqlite3_column_int(res, 9);
        t.trackingSpeedAttributeID = sqlite3_column_int(res, 10);
        t.dischargeAttributeID = sqlite3_column_int(res, 11);
        t.rangeAttributeID = sqlite3_column_int(res, 12);
        t.falloffAttributeID = sqlite3_column_int(res, 13);
        t.disallowAutoRepeat = sqlite3_column_int(res, 14);
        t.published = sqlite3_column_int(res, 15);
        char *_v16 = (char *)sqlite3_column_text(res, 16);
        if (_v16 != NULL) {
            t.displayName = strdup(_v16);
        }
        t.isWarpSafe = sqlite3_column_int(res, 17);
        t.rangeChance = sqlite3_column_int(res, 18);
        t.electronicChance = sqlite3_column_int(res, 19);
        t.propulsionChance = sqlite3_column_int(res, 20);
        t.distribution = sqlite3_column_int(res, 21);
        char *_v22 = (char *)sqlite3_column_text(res, 22);
        if (_v22 != NULL) {
            t.sfxName = strdup(_v22);
        }
        t.npcUsageChanceAttributeID = sqlite3_column_int(res, 23);
        t.npcActivationChanceAttributeID = sqlite3_column_int(res, 24);
        t.fittingUsageChanceAttributeID = sqlite3_column_int(res, 25);
        t.iconID = sqlite3_column_int(res, 26);
        t.displayNameID = sqlite3_column_int(res, 27);
        t.descriptionID = sqlite3_column_int(res, 28);
        t.dataID = sqlite3_column_int(res, 29);
    }

    sqlite3_finalize(res);
    return t;
}

cacheRamCompletedStatuses cacheRamCompletedStatuses_load_by(bulkdata *b, uint32_t completedStatus) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheRamCompletedStatuses t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamCompletedStatuses where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, completedStatus);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.completedStatus = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.completedStatusText = strdup(_v1);
        }
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        }
        t.completedStatusTextID = sqlite3_column_int(res, 3);
    }

    sqlite3_finalize(res);
    return t;
}

cacheInvBlueprintTypes cacheInvBlueprintTypes_load_by(bulkdata *b, uint32_t blueprintTypeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheInvBlueprintTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvBlueprintTypes where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, blueprintTypeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.blueprintTypeID = sqlite3_column_int(res, 0);
        t.parentBlueprintTypeID = sqlite3_column_int(res, 1);
        t.productTypeID = sqlite3_column_int(res, 2);
        t.productionTime = sqlite3_column_int(res, 3);
        t.techLevel = sqlite3_column_int(res, 4);
        t.researchProductivityTime = sqlite3_column_int(res, 5);
        t.researchMaterialTime = sqlite3_column_int(res, 6);
        t.researchCopyTime = sqlite3_column_int(res, 7);
        t.researchTechTime = sqlite3_column_int(res, 8);
        t.productivityModifier = sqlite3_column_int(res, 9);
        t.materialModifier = sqlite3_column_int(res, 10);
        t.wasteFactor = sqlite3_column_int(res, 11);
        t.chanceOfReverseEngineering = sqlite3_column_double(res, 12);
        t.maxProductionLimit = sqlite3_column_int(res, 13);
    }

    sqlite3_finalize(res);
    return t;
}

cacheRamTypeRequirements cacheRamTypeRequirements_load_by(bulkdata *b, uint32_t typeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheRamTypeRequirements t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamTypeRequirements where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, typeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.activityID = sqlite3_column_int(res, 1);
        t.requiredTypeID = sqlite3_column_int(res, 2);
        t.quantity = sqlite3_column_int(res, 3);
        t.damagePerJob = sqlite3_column_double(res, 4);
        t.recycle = sqlite3_column_int(res, 5);
    }

    sqlite3_finalize(res);
    return t;
}

cacheCertificateRelationships cacheCertificateRelationships_load_by(bulkdata *b, uint32_t relationshipID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheCertificateRelationships t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheCertificateRelationships where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, relationshipID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.relationshipID = sqlite3_column_int(res, 0);
        t.parentID = sqlite3_column_int(res, 1);
        t.parentTypeID = sqlite3_column_int(res, 2);
        t.parentLevel = sqlite3_column_int(res, 3);
        t.childID = sqlite3_column_int(res, 4);
        t.childTypeID = sqlite3_column_int(res, 5);
    }

    sqlite3_finalize(res);
    return t;
}

cacheDogmaAttributes cacheDogmaAttributes_load_by(bulkdata *b, uint32_t attributeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheDogmaAttributes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaAttributes where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, attributeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.attributeID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.attributeName = strdup(_v1);
        }
        t.attributeCategory = sqlite3_column_int(res, 2);
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        }
        t.maxAttributeID = sqlite3_column_int(res, 4);
        t.attributeIdx = sqlite3_column_int(res, 5);
        t.chargeRechargeTimeID = sqlite3_column_int(res, 6);
        t.defaultValue = sqlite3_column_double(res, 7);
        t.published = sqlite3_column_int(res, 8);
        char *_v9 = (char *)sqlite3_column_text(res, 9);
        if (_v9 != NULL) {
            t.displayName = strdup(_v9);
        }
        t.unitID = sqlite3_column_int(res, 10);
        t.stackable = sqlite3_column_int(res, 11);
        t.highIsGood = sqlite3_column_int(res, 12);
        t.categoryID = sqlite3_column_int(res, 13);
        t.iconID = sqlite3_column_int(res, 14);
        t.displayNameID = sqlite3_column_int(res, 15);
        t.dataID = sqlite3_column_int(res, 16);
    }

    sqlite3_finalize(res);
    return t;
}

cacheRamAssemblyLineTypes cacheRamAssemblyLineTypes_load_by(bulkdata *b, uint32_t assemblyLineTypeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheRamAssemblyLineTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamAssemblyLineTypes where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, assemblyLineTypeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.assemblyLineTypeID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.assemblyLineTypeName = strdup(_v1);
        }
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        }
        t.baseTimeMultiplier = sqlite3_column_double(res, 3);
        t.baseMaterialMultiplier = sqlite3_column_double(res, 4);
        t.volume = sqlite3_column_double(res, 5);
        t.activityID = sqlite3_column_int(res, 6);
        t.minCostPerHour = sqlite3_column_double(res, 7);
    }

    sqlite3_finalize(res);
    return t;
}

cacheStaStationsStatic cacheStaStationsStatic_load_by(bulkdata *b, uint32_t stationID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheStaStationsStatic t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheStaStationsStatic where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, stationID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.stationID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.stationName = strdup(_v1);
        }
        t.x = sqlite3_column_double(res, 2);
        t.y = sqlite3_column_double(res, 3);
        t.z = sqlite3_column_double(res, 4);
        t.stationTypeID = sqlite3_column_int(res, 5);
        t.solarSystemID = sqlite3_column_int(res, 6);
    }

    sqlite3_finalize(res);
    return t;
}

cacheInvGroups cacheInvGroups_load_by(bulkdata *b, uint32_t groupID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheInvGroups t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvGroups where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, groupID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.groupID = sqlite3_column_int(res, 0);
        t.categoryID = sqlite3_column_int(res, 1);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.groupName = strdup(_v2);
        }
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        }
        t.useBasePrice = sqlite3_column_int(res, 4);
        t.allowManufacture = sqlite3_column_int(res, 5);
        t.allowRecycler = sqlite3_column_int(res, 6);
        t.anchored = sqlite3_column_int(res, 7);
        t.anchorable = sqlite3_column_int(res, 8);
        t.fittableNonSingleton = sqlite3_column_int(res, 9);
        t.published = sqlite3_column_int(res, 10);
        t.iconID = sqlite3_column_int(res, 11);
        t.groupNameID = sqlite3_column_int(res, 12);
        t.dataID = sqlite3_column_int(res, 13);
    }

    sqlite3_finalize(res);
    return t;
}

cacheInvMetaTypes cacheInvMetaTypes_load_by(bulkdata *b, uint32_t typeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheInvMetaTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvMetaTypes where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, typeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.parentTypeID = sqlite3_column_int(res, 1);
        t.metaGroupID = sqlite3_column_int(res, 2);
    }

    sqlite3_finalize(res);
    return t;
}

cacheInvTypeReactions cacheInvTypeReactions_load_by(bulkdata *b, uint32_t reactionTypeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheInvTypeReactions t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvTypeReactions where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, reactionTypeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.reactionTypeID = sqlite3_column_int(res, 0);
        t.input = sqlite3_column_int(res, 1);
        t.typeID = sqlite3_column_int(res, 2);
        t.quantity = sqlite3_column_int(res, 3);
    }

    sqlite3_finalize(res);
    return t;
}

cacheDogmaTypeEffects cacheDogmaTypeEffects_load_by(bulkdata *b, uint32_t typeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheDogmaTypeEffects t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaTypeEffects where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, typeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.effectID = sqlite3_column_int(res, 1);
        t.isDefault = sqlite3_column_int(res, 2);
    }

    sqlite3_finalize(res);
    return t;
}

cachePlanetSchematics cachePlanetSchematics_load_by(bulkdata *b, uint32_t schematicID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cachePlanetSchematics t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cachePlanetSchematics where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, schematicID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.schematicID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.schematicName = strdup(_v1);
        }
        t.cycleTime = sqlite3_column_int(res, 2);
        t.schematicNameID = sqlite3_column_int(res, 3);
        t.dataID = sqlite3_column_int(res, 4);
    }

    sqlite3_finalize(res);
    return t;
}

cacheDogmaUnits cacheDogmaUnits_load_by(bulkdata *b, uint32_t unitID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheDogmaUnits t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaUnits where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, unitID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.unitID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.unitName = strdup(_v1);
        }
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.displayName = strdup(_v2);
        }
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        }
        t.displayNameID = sqlite3_column_int(res, 4);
        t.descriptionID = sqlite3_column_int(res, 5);
        t.dataID = sqlite3_column_int(res, 6);
    }

    sqlite3_finalize(res);
    return t;
}

cachePlanetSchematicsTypeMap cachePlanetSchematicsTypeMap_load_by(bulkdata *b, uint32_t schematicID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cachePlanetSchematicsTypeMap t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cachePlanetSchematicsTypeMap where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, schematicID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.schematicID = sqlite3_column_int(res, 0);
        t.typeID = sqlite3_column_int(res, 1);
        t.isInput = sqlite3_column_int(res, 2);
        t.quantity = sqlite3_column_int(res, 3);
    }

    sqlite3_finalize(res);
    return t;
}

cacheDogmaTypeAttributes cacheDogmaTypeAttributes_load_by(bulkdata *b, uint32_t typeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheDogmaTypeAttributes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaTypeAttributes where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, typeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.attributeID = sqlite3_column_int(res, 1);
        t.value = sqlite3_column_double(res, 2);
    }

    sqlite3_finalize(res);
    return t;
}

cacheDogmaExpressions cacheDogmaExpressions_load_by(bulkdata *b, uint32_t expressionID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheDogmaExpressions t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaExpressions where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, expressionID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.expressionID = sqlite3_column_int(res, 0);
        t.operandID = sqlite3_column_int(res, 1);
        t.arg1 = sqlite3_column_int(res, 2);
        t.arg2 = sqlite3_column_int(res, 3);
        char *_v4 = (char *)sqlite3_column_text(res, 4);
        if (_v4 != NULL) {
            t.expressionValue = strdup(_v4);
        }
        char *_v5 = (char *)sqlite3_column_text(res, 5);
        if (_v5 != NULL) {
            t.description = strdup(_v5);
        }
        char *_v6 = (char *)sqlite3_column_text(res, 6);
        if (_v6 != NULL) {
            t.expressionName = strdup(_v6);
        }
        t.expressionTypeID = sqlite3_column_int(res, 7);
        t.expressionGroupID = sqlite3_column_int(res, 8);
        t.expressionAttributeID = sqlite3_column_int(res, 9);
    }

    sqlite3_finalize(res);
    return t;
}

cacheRamAssemblyLineTypesGroup cacheRamAssemblyLineTypesGroup_load_by(bulkdata *b, uint32_t assemblyLineTypeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheRamAssemblyLineTypesGroup t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamAssemblyLineTypesGroup where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, assemblyLineTypeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.assemblyLineTypeID = sqlite3_column_int(res, 0);
        t.groupID = sqlite3_column_int(res, 1);
        t.timeMultiplier = sqlite3_column_double(res, 2);
        t.materialMultiplier = sqlite3_column_double(res, 3);
        char *_v4 = (char *)sqlite3_column_text(res, 4);
        if (_v4 != NULL) {
            t.activityID = strdup(_v4);
        }
    }

    sqlite3_finalize(res);
    return t;
}

cacheResGraphics cacheResGraphics_load_by(bulkdata *b, uint32_t graphicID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheResGraphics t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheResGraphics where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, graphicID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.graphicID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.graphicFile = strdup(_v1);
        }
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.graphicName = strdup(_v2);
        }
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        }
        t.obsolete = sqlite3_column_int(res, 4);
        char *_v5 = (char *)sqlite3_column_text(res, 5);
        if (_v5 != NULL) {
            t.graphicType = strdup(_v5);
        }
        char *_v6 = (char *)sqlite3_column_text(res, 6);
        if (_v6 != NULL) {
            t.collisionFile = strdup(_v6);
        }
        char *_v7 = (char *)sqlite3_column_text(res, 7);
        if (_v7 != NULL) {
            t.paperdollFile = strdup(_v7);
        }
        t.animationTemplate = sqlite3_column_int(res, 8);
        t.collidable = sqlite3_column_int(res, 9);
        t.explosionID = sqlite3_column_int(res, 10);
        t.directoryID = sqlite3_column_int(res, 11);
        t.graphicMinX = sqlite3_column_double(res, 12);
        t.graphicMinY = sqlite3_column_double(res, 13);
        t.graphicMinZ = sqlite3_column_double(res, 14);
        t.graphicMaxX = sqlite3_column_double(res, 15);
        t.graphicMaxY = sqlite3_column_double(res, 16);
        t.graphicMaxZ = sqlite3_column_double(res, 17);
        t.isPrototype = sqlite3_column_int(res, 18);
    }

    sqlite3_finalize(res);
    return t;
}

cacheInvTypes cacheInvTypes_load_by(bulkdata *b, uint32_t typeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheInvTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvTypes where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, typeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.groupID = sqlite3_column_int(res, 1);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.typeName = strdup(_v2);
        }
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        }
        t.graphicID = sqlite3_column_int(res, 4);
        t.radius = sqlite3_column_double(res, 5);
        t.mass = sqlite3_column_double(res, 6);
        t.volume = sqlite3_column_double(res, 7);
        t.capacity = sqlite3_column_double(res, 8);
        t.portionSize = sqlite3_column_int(res, 9);
        t.raceID = sqlite3_column_int(res, 10);
        t.basePrice = sqlite3_column_double(res, 11);
        t.published = sqlite3_column_int(res, 12);
        t.marketGroupID = sqlite3_column_int(res, 13);
        t.chanceOfDuplicating = sqlite3_column_double(res, 14);
        t.soundID = sqlite3_column_int(res, 15);
        t.iconID = sqlite3_column_int(res, 16);
        t.dataID = sqlite3_column_int(res, 17);
        t.typeNameID = sqlite3_column_int(res, 18);
        t.descriptionID = sqlite3_column_int(res, 19);
        t.copyTypeID = sqlite3_column_int(res, 20);
    }

    sqlite3_finalize(res);
    return t;
}

cacheResIcons cacheResIcons_load_by(bulkdata *b, uint32_t iconID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheResIcons t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheResIcons where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, iconID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.iconID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.iconFile = strdup(_v1);
        }
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        }
        t.obsolete = sqlite3_column_int(res, 3);
        char *_v4 = (char *)sqlite3_column_text(res, 4);
        if (_v4 != NULL) {
            t.iconType = strdup(_v4);
        }
        t.directoryID = sqlite3_column_int(res, 5);
    }

    sqlite3_finalize(res);
    return t;
}

cacheActBillTypes cacheActBillTypes_load_by(bulkdata *b, uint32_t billTypeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheActBillTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheActBillTypes where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, billTypeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.billTypeID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.billTypeName = strdup(_v1);
        }
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        }
        t.billTypeNameID = sqlite3_column_int(res, 3);
        t.dataID = sqlite3_column_int(res, 4);
    }

    sqlite3_finalize(res);
    return t;
}

cachePlanetSchematicsPinMap cachePlanetSchematicsPinMap_load_by(bulkdata *b, uint32_t schematicID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cachePlanetSchematicsPinMap t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cachePlanetSchematicsPinMap where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, schematicID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.schematicID = sqlite3_column_int(res, 0);
        t.pinTypeID = sqlite3_column_int(res, 1);
    }

    sqlite3_finalize(res);
    return t;
}

cacheInvContrabandTypes cacheInvContrabandTypes_load_by(bulkdata *b, uint32_t factionID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheInvContrabandTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvContrabandTypes where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, factionID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.factionID = sqlite3_column_int(res, 0);
        t.typeID = sqlite3_column_int(res, 1);
        t.standingLoss = sqlite3_column_double(res, 2);
        t.confiscateMinSec = sqlite3_column_double(res, 3);
        t.fineByValue = sqlite3_column_double(res, 4);
        t.attackMinSec = sqlite3_column_double(res, 5);
    }

    sqlite3_finalize(res);
    return t;
}

cacheInvMetaGroups cacheInvMetaGroups_load_by(bulkdata *b, uint32_t metaGroupID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheInvMetaGroups t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvMetaGroups where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, metaGroupID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.metaGroupID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.metaGroupName = strdup(_v1);
        }
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        }
        t.iconID = sqlite3_column_int(res, 3);
        t.metaGroupNameID = sqlite3_column_int(res, 4);
        t.descriptionID = sqlite3_column_int(res, 5);
        t.dataID = sqlite3_column_int(res, 6);
    }

    sqlite3_finalize(res);
    return t;
}

cacheCertificates cacheCertificates_load_by(bulkdata *b, uint32_t certificateID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheCertificates t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheCertificates where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, certificateID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.certificateID = sqlite3_column_int(res, 0);
        t.categoryID = sqlite3_column_int(res, 1);
        t.classID = sqlite3_column_int(res, 2);
        t.grade = sqlite3_column_int(res, 3);
        t.corpID = sqlite3_column_int(res, 4);
        t.iconID = sqlite3_column_int(res, 5);
        char *_v6 = (char *)sqlite3_column_text(res, 6);
        if (_v6 != NULL) {
            t.description = strdup(_v6);
        }
        t.descriptionID = sqlite3_column_int(res, 7);
        t.dataID = sqlite3_column_int(res, 8);
    }

    sqlite3_finalize(res);
    return t;
}

cacheInvTypeMaterials cacheInvTypeMaterials_load_by(bulkdata *b, uint32_t typeID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheInvTypeMaterials t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvTypeMaterials where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, typeID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.materialTypeID = sqlite3_column_int(res, 1);
        t.quantity = sqlite3_column_int(res, 2);
    }

    sqlite3_finalize(res);
    return t;
}

cacheResSounds cacheResSounds_load_by(bulkdata *b, uint32_t soundID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheResSounds t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheResSounds where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, soundID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.soundID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.soundFile = strdup(_v1);
        }
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        }
        t.obsolete = sqlite3_column_int(res, 3);
    }

    sqlite3_finalize(res);
    return t;
}

cacheRamActivities cacheRamActivities_load_by(bulkdata *b, uint32_t activityID) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    cacheRamActivities t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamActivities where typeID = @id";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc == SQLITE_OK) {
        int idx = sqlite3_bind_parameter_index(res, "@id");
        sqlite3_bind_int(res, idx, activityID);
    } else {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
        t.activityID = sqlite3_column_int(res, 0);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.activityName = strdup(_v1);
        }
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.iconNo = strdup(_v2);
        }
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        }
        t.published = sqlite3_column_int(res, 4);
        t.activityNameID = sqlite3_column_int(res, 5);
        t.descriptionID = sqlite3_column_int(res, 6);
    }

    sqlite3_finalize(res);
    return t;
}

std::vector<cacheShipTypes> cacheShipTypes_load_all(bulkdata *b) {
    printf("Loading cacheShipTypes\n");
    std::vector<cacheShipTypes> out;
    sqlite3_stmt *res;
    cacheShipTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheShipTypes";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.shipTypeID = sqlite3_column_int(res, 0);
        t.weaponTypeID = sqlite3_column_int(res, 1);
        t.miningTypeID = sqlite3_column_int(res, 2);
        t.skillTypeID = sqlite3_column_int(res, 3);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheStaOperations> cacheStaOperations_load_all(bulkdata *b) {
    printf("Loading cacheStaOperations\n");
    std::vector<cacheStaOperations> out;
    sqlite3_stmt *res;
    cacheStaOperations t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheStaOperations";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.activityID = sqlite3_column_int(res, 0);
        t.operationID = sqlite3_column_int(res, 1);
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.operationName = strdup(_v2);
        } else { 
            t.operationName = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.operationName = NULL;
        }
        int32_t _t3 = sqlite3_column_type(res, 3);
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        } else { 
            t.description = NULL;
        }
        if (_t3 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.fringe = sqlite3_column_int(res, 4);
        t.corridor = sqlite3_column_int(res, 5);
        t.hub = sqlite3_column_int(res, 6);
        t.border = sqlite3_column_int(res, 7);
        t.ratio = sqlite3_column_int(res, 8);
        t.caldariStationTypeID = sqlite3_column_int(res, 9);
        t.minmatarStationTypeID = sqlite3_column_int(res, 10);
        t.amarrStationTypeID = sqlite3_column_int(res, 11);
        t.gallenteStationTypeID = sqlite3_column_int(res, 12);
        t.joveStationTypeID = sqlite3_column_int(res, 13);
        t.operationNameID = sqlite3_column_int(res, 14);
        t.descriptionID = sqlite3_column_int(res, 15);
        t.serviceMask = sqlite3_column_int(res, 16);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheRamAssemblyLineTypesCategory> cacheRamAssemblyLineTypesCategory_load_all(bulkdata *b) {
    printf("Loading cacheRamAssemblyLineTypesCategory\n");
    std::vector<cacheRamAssemblyLineTypesCategory> out;
    sqlite3_stmt *res;
    cacheRamAssemblyLineTypesCategory t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamAssemblyLineTypesCategory";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.assemblyLineTypeID = sqlite3_column_int(res, 0);
        t.categoryID = sqlite3_column_int(res, 1);
        t.timeMultiplier = sqlite3_column_double(res, 2);
        t.materialMultiplier = sqlite3_column_double(res, 3);
        int32_t _t4 = sqlite3_column_type(res, 4);
        char *_v4 = (char *)sqlite3_column_text(res, 4);
        if (_v4 != NULL) {
            t.activityID = strdup(_v4);
        } else { 
            t.activityID = NULL;
        }
        if (_t4 == SQLITE_NULL) {
            t.activityID = NULL;
        }
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheInvCategories> cacheInvCategories_load_all(bulkdata *b) {
    printf("Loading cacheInvCategories\n");
    std::vector<cacheInvCategories> out;
    sqlite3_stmt *res;
    cacheInvCategories t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvCategories";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.categoryID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.categoryName = strdup(_v1);
        } else { 
            t.categoryName = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.categoryName = NULL;
        }
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        } else { 
            t.description = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.published = sqlite3_column_int(res, 3);
        t.iconID = sqlite3_column_int(res, 4);
        t.categoryNameID = sqlite3_column_int(res, 5);
        t.dataID = sqlite3_column_int(res, 6);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheDogmaEffects> cacheDogmaEffects_load_all(bulkdata *b) {
    printf("Loading cacheDogmaEffects\n");
    std::vector<cacheDogmaEffects> out;
    sqlite3_stmt *res;
    cacheDogmaEffects t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaEffects";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.effectID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.effectName = strdup(_v1);
        } else { 
            t.effectName = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.effectName = NULL;
        }
        t.effectCategory = sqlite3_column_int(res, 2);
        t.preExpression = sqlite3_column_int(res, 3);
        t.postExpression = sqlite3_column_int(res, 4);
        int32_t _t5 = sqlite3_column_type(res, 5);
        char *_v5 = (char *)sqlite3_column_text(res, 5);
        if (_v5 != NULL) {
            t.description = strdup(_v5);
        } else { 
            t.description = NULL;
        }
        if (_t5 == SQLITE_NULL) {
            t.description = NULL;
        }
        int32_t _t6 = sqlite3_column_type(res, 6);
        char *_v6 = (char *)sqlite3_column_text(res, 6);
        if (_v6 != NULL) {
            t.guid = strdup(_v6);
        } else { 
            t.guid = NULL;
        }
        if (_t6 == SQLITE_NULL) {
            t.guid = NULL;
        }
        t.isOffensive = sqlite3_column_int(res, 7);
        t.isAssistance = sqlite3_column_int(res, 8);
        t.durationAttributeID = sqlite3_column_int(res, 9);
        t.trackingSpeedAttributeID = sqlite3_column_int(res, 10);
        t.dischargeAttributeID = sqlite3_column_int(res, 11);
        t.rangeAttributeID = sqlite3_column_int(res, 12);
        t.falloffAttributeID = sqlite3_column_int(res, 13);
        t.disallowAutoRepeat = sqlite3_column_int(res, 14);
        t.published = sqlite3_column_int(res, 15);
        int32_t _t16 = sqlite3_column_type(res, 16);
        char *_v16 = (char *)sqlite3_column_text(res, 16);
        if (_v16 != NULL) {
            t.displayName = strdup(_v16);
        } else { 
            t.displayName = NULL;
        }
        if (_t16 == SQLITE_NULL) {
            t.displayName = NULL;
        }
        t.isWarpSafe = sqlite3_column_int(res, 17);
        t.rangeChance = sqlite3_column_int(res, 18);
        t.electronicChance = sqlite3_column_int(res, 19);
        t.propulsionChance = sqlite3_column_int(res, 20);
        t.distribution = sqlite3_column_int(res, 21);
        int32_t _t22 = sqlite3_column_type(res, 22);
        char *_v22 = (char *)sqlite3_column_text(res, 22);
        if (_v22 != NULL) {
            t.sfxName = strdup(_v22);
        } else { 
            t.sfxName = NULL;
        }
        if (_t22 == SQLITE_NULL) {
            t.sfxName = NULL;
        }
        t.npcUsageChanceAttributeID = sqlite3_column_int(res, 23);
        t.npcActivationChanceAttributeID = sqlite3_column_int(res, 24);
        t.fittingUsageChanceAttributeID = sqlite3_column_int(res, 25);
        t.iconID = sqlite3_column_int(res, 26);
        t.displayNameID = sqlite3_column_int(res, 27);
        t.descriptionID = sqlite3_column_int(res, 28);
        t.dataID = sqlite3_column_int(res, 29);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheRamCompletedStatuses> cacheRamCompletedStatuses_load_all(bulkdata *b) {
    printf("Loading cacheRamCompletedStatuses\n");
    std::vector<cacheRamCompletedStatuses> out;
    sqlite3_stmt *res;
    cacheRamCompletedStatuses t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamCompletedStatuses";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.completedStatus = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.completedStatusText = strdup(_v1);
        } else { 
            t.completedStatusText = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.completedStatusText = NULL;
        }
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        } else { 
            t.description = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.completedStatusTextID = sqlite3_column_int(res, 3);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheInvBlueprintTypes> cacheInvBlueprintTypes_load_all(bulkdata *b) {
    printf("Loading cacheInvBlueprintTypes\n");
    std::vector<cacheInvBlueprintTypes> out;
    sqlite3_stmt *res;
    cacheInvBlueprintTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvBlueprintTypes";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.blueprintTypeID = sqlite3_column_int(res, 0);
        t.parentBlueprintTypeID = sqlite3_column_int(res, 1);
        t.productTypeID = sqlite3_column_int(res, 2);
        t.productionTime = sqlite3_column_int(res, 3);
        t.techLevel = sqlite3_column_int(res, 4);
        t.researchProductivityTime = sqlite3_column_int(res, 5);
        t.researchMaterialTime = sqlite3_column_int(res, 6);
        t.researchCopyTime = sqlite3_column_int(res, 7);
        t.researchTechTime = sqlite3_column_int(res, 8);
        t.productivityModifier = sqlite3_column_int(res, 9);
        t.materialModifier = sqlite3_column_int(res, 10);
        t.wasteFactor = sqlite3_column_int(res, 11);
        t.chanceOfReverseEngineering = sqlite3_column_double(res, 12);
        t.maxProductionLimit = sqlite3_column_int(res, 13);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheRamTypeRequirements> cacheRamTypeRequirements_load_all(bulkdata *b) {
    printf("Loading cacheRamTypeRequirements\n");
    std::vector<cacheRamTypeRequirements> out;
    sqlite3_stmt *res;
    cacheRamTypeRequirements t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamTypeRequirements";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.activityID = sqlite3_column_int(res, 1);
        t.requiredTypeID = sqlite3_column_int(res, 2);
        t.quantity = sqlite3_column_int(res, 3);
        t.damagePerJob = sqlite3_column_double(res, 4);
        t.recycle = sqlite3_column_int(res, 5);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheCertificateRelationships> cacheCertificateRelationships_load_all(bulkdata *b) {
    printf("Loading cacheCertificateRelationships\n");
    std::vector<cacheCertificateRelationships> out;
    sqlite3_stmt *res;
    cacheCertificateRelationships t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheCertificateRelationships";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.relationshipID = sqlite3_column_int(res, 0);
        t.parentID = sqlite3_column_int(res, 1);
        t.parentTypeID = sqlite3_column_int(res, 2);
        t.parentLevel = sqlite3_column_int(res, 3);
        t.childID = sqlite3_column_int(res, 4);
        t.childTypeID = sqlite3_column_int(res, 5);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheDogmaAttributes> cacheDogmaAttributes_load_all(bulkdata *b) {
    printf("Loading cacheDogmaAttributes\n");
    std::vector<cacheDogmaAttributes> out;
    sqlite3_stmt *res;
    cacheDogmaAttributes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaAttributes";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.attributeID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.attributeName = strdup(_v1);
        } else { 
            t.attributeName = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.attributeName = NULL;
        }
        t.attributeCategory = sqlite3_column_int(res, 2);
        int32_t _t3 = sqlite3_column_type(res, 3);
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        } else { 
            t.description = NULL;
        }
        if (_t3 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.maxAttributeID = sqlite3_column_int(res, 4);
        t.attributeIdx = sqlite3_column_int(res, 5);
        t.chargeRechargeTimeID = sqlite3_column_int(res, 6);
        t.defaultValue = sqlite3_column_double(res, 7);
        t.published = sqlite3_column_int(res, 8);
        int32_t _t9 = sqlite3_column_type(res, 9);
        char *_v9 = (char *)sqlite3_column_text(res, 9);
        if (_v9 != NULL) {
            t.displayName = strdup(_v9);
        } else { 
            t.displayName = NULL;
        }
        if (_t9 == SQLITE_NULL) {
            t.displayName = NULL;
        }
        t.unitID = sqlite3_column_int(res, 10);
        t.stackable = sqlite3_column_int(res, 11);
        t.highIsGood = sqlite3_column_int(res, 12);
        t.categoryID = sqlite3_column_int(res, 13);
        t.iconID = sqlite3_column_int(res, 14);
        t.displayNameID = sqlite3_column_int(res, 15);
        t.dataID = sqlite3_column_int(res, 16);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheRamAssemblyLineTypes> cacheRamAssemblyLineTypes_load_all(bulkdata *b) {
    printf("Loading cacheRamAssemblyLineTypes\n");
    std::vector<cacheRamAssemblyLineTypes> out;
    sqlite3_stmt *res;
    cacheRamAssemblyLineTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamAssemblyLineTypes";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.assemblyLineTypeID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.assemblyLineTypeName = strdup(_v1);
        } else { 
            t.assemblyLineTypeName = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.assemblyLineTypeName = NULL;
        }
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        } else { 
            t.description = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.baseTimeMultiplier = sqlite3_column_double(res, 3);
        t.baseMaterialMultiplier = sqlite3_column_double(res, 4);
        t.volume = sqlite3_column_double(res, 5);
        t.activityID = sqlite3_column_int(res, 6);
        t.minCostPerHour = sqlite3_column_double(res, 7);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheStaStationsStatic> cacheStaStationsStatic_load_all(bulkdata *b) {
    printf("Loading cacheStaStationsStatic\n");
    std::vector<cacheStaStationsStatic> out;
    sqlite3_stmt *res;
    cacheStaStationsStatic t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheStaStationsStatic";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.stationID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.stationName = strdup(_v1);
        } else { 
            t.stationName = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.stationName = NULL;
        }
        t.x = sqlite3_column_double(res, 2);
        t.y = sqlite3_column_double(res, 3);
        t.z = sqlite3_column_double(res, 4);
        t.stationTypeID = sqlite3_column_int(res, 5);
        t.solarSystemID = sqlite3_column_int(res, 6);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheInvGroups> cacheInvGroups_load_all(bulkdata *b) {
    printf("Loading cacheInvGroups\n");
    std::vector<cacheInvGroups> out;
    sqlite3_stmt *res;
    cacheInvGroups t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvGroups";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.groupID = sqlite3_column_int(res, 0);
        t.categoryID = sqlite3_column_int(res, 1);
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.groupName = strdup(_v2);
        } else { 
            t.groupName = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.groupName = NULL;
        }
        int32_t _t3 = sqlite3_column_type(res, 3);
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        } else { 
            t.description = NULL;
        }
        if (_t3 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.useBasePrice = sqlite3_column_int(res, 4);
        t.allowManufacture = sqlite3_column_int(res, 5);
        t.allowRecycler = sqlite3_column_int(res, 6);
        t.anchored = sqlite3_column_int(res, 7);
        t.anchorable = sqlite3_column_int(res, 8);
        t.fittableNonSingleton = sqlite3_column_int(res, 9);
        t.published = sqlite3_column_int(res, 10);
        t.iconID = sqlite3_column_int(res, 11);
        t.groupNameID = sqlite3_column_int(res, 12);
        t.dataID = sqlite3_column_int(res, 13);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheInvMetaTypes> cacheInvMetaTypes_load_all(bulkdata *b) {
    printf("Loading cacheInvMetaTypes\n");
    std::vector<cacheInvMetaTypes> out;
    sqlite3_stmt *res;
    cacheInvMetaTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvMetaTypes";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.parentTypeID = sqlite3_column_int(res, 1);
        t.metaGroupID = sqlite3_column_int(res, 2);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheInvTypeReactions> cacheInvTypeReactions_load_all(bulkdata *b) {
    printf("Loading cacheInvTypeReactions\n");
    std::vector<cacheInvTypeReactions> out;
    sqlite3_stmt *res;
    cacheInvTypeReactions t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvTypeReactions";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.reactionTypeID = sqlite3_column_int(res, 0);
        t.input = sqlite3_column_int(res, 1);
        t.typeID = sqlite3_column_int(res, 2);
        t.quantity = sqlite3_column_int(res, 3);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheDogmaTypeEffects> cacheDogmaTypeEffects_load_all(bulkdata *b) {
    printf("Loading cacheDogmaTypeEffects\n");
    std::vector<cacheDogmaTypeEffects> out;
    sqlite3_stmt *res;
    cacheDogmaTypeEffects t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaTypeEffects";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.effectID = sqlite3_column_int(res, 1);
        t.isDefault = sqlite3_column_int(res, 2);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cachePlanetSchematics> cachePlanetSchematics_load_all(bulkdata *b) {
    printf("Loading cachePlanetSchematics\n");
    std::vector<cachePlanetSchematics> out;
    sqlite3_stmt *res;
    cachePlanetSchematics t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cachePlanetSchematics";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.schematicID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.schematicName = strdup(_v1);
        } else { 
            t.schematicName = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.schematicName = NULL;
        }
        t.cycleTime = sqlite3_column_int(res, 2);
        t.schematicNameID = sqlite3_column_int(res, 3);
        t.dataID = sqlite3_column_int(res, 4);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheDogmaUnits> cacheDogmaUnits_load_all(bulkdata *b) {
    printf("Loading cacheDogmaUnits\n");
    std::vector<cacheDogmaUnits> out;
    sqlite3_stmt *res;
    cacheDogmaUnits t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaUnits";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.unitID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.unitName = strdup(_v1);
        } else { 
            t.unitName = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.unitName = NULL;
        }
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.displayName = strdup(_v2);
        } else { 
            t.displayName = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.displayName = NULL;
        }
        int32_t _t3 = sqlite3_column_type(res, 3);
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        } else { 
            t.description = NULL;
        }
        if (_t3 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.displayNameID = sqlite3_column_int(res, 4);
        t.descriptionID = sqlite3_column_int(res, 5);
        t.dataID = sqlite3_column_int(res, 6);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cachePlanetSchematicsTypeMap> cachePlanetSchematicsTypeMap_load_all(bulkdata *b) {
    printf("Loading cachePlanetSchematicsTypeMap\n");
    std::vector<cachePlanetSchematicsTypeMap> out;
    sqlite3_stmt *res;
    cachePlanetSchematicsTypeMap t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cachePlanetSchematicsTypeMap";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.schematicID = sqlite3_column_int(res, 0);
        t.typeID = sqlite3_column_int(res, 1);
        t.isInput = sqlite3_column_int(res, 2);
        t.quantity = sqlite3_column_int(res, 3);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheDogmaTypeAttributes> cacheDogmaTypeAttributes_load_all(bulkdata *b) {
    printf("Loading cacheDogmaTypeAttributes\n");
    std::vector<cacheDogmaTypeAttributes> out;
    sqlite3_stmt *res;
    cacheDogmaTypeAttributes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaTypeAttributes";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.attributeID = sqlite3_column_int(res, 1);
        t.value = sqlite3_column_double(res, 2);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheDogmaExpressions> cacheDogmaExpressions_load_all(bulkdata *b) {
    printf("Loading cacheDogmaExpressions\n");
    std::vector<cacheDogmaExpressions> out;
    sqlite3_stmt *res;
    cacheDogmaExpressions t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheDogmaExpressions";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.expressionID = sqlite3_column_int(res, 0);
        t.operandID = sqlite3_column_int(res, 1);
        t.arg1 = sqlite3_column_int(res, 2);
        t.arg2 = sqlite3_column_int(res, 3);
        int32_t _t4 = sqlite3_column_type(res, 4);
        char *_v4 = (char *)sqlite3_column_text(res, 4);
        if (_v4 != NULL) {
            t.expressionValue = strdup(_v4);
        } else { 
            t.expressionValue = NULL;
        }
        if (_t4 == SQLITE_NULL) {
            t.expressionValue = NULL;
        }
        int32_t _t5 = sqlite3_column_type(res, 5);
        char *_v5 = (char *)sqlite3_column_text(res, 5);
        if (_v5 != NULL) {
            t.description = strdup(_v5);
        } else { 
            t.description = NULL;
        }
        if (_t5 == SQLITE_NULL) {
            t.description = NULL;
        }
        int32_t _t6 = sqlite3_column_type(res, 6);
        char *_v6 = (char *)sqlite3_column_text(res, 6);
        if (_v6 != NULL) {
            t.expressionName = strdup(_v6);
        } else { 
            t.expressionName = NULL;
        }
        if (_t6 == SQLITE_NULL) {
            t.expressionName = NULL;
        }
        t.expressionTypeID = sqlite3_column_int(res, 7);
        t.expressionGroupID = sqlite3_column_int(res, 8);
        t.expressionAttributeID = sqlite3_column_int(res, 9);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheRamAssemblyLineTypesGroup> cacheRamAssemblyLineTypesGroup_load_all(bulkdata *b) {
    printf("Loading cacheRamAssemblyLineTypesGroup\n");
    std::vector<cacheRamAssemblyLineTypesGroup> out;
    sqlite3_stmt *res;
    cacheRamAssemblyLineTypesGroup t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamAssemblyLineTypesGroup";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.assemblyLineTypeID = sqlite3_column_int(res, 0);
        t.groupID = sqlite3_column_int(res, 1);
        t.timeMultiplier = sqlite3_column_double(res, 2);
        t.materialMultiplier = sqlite3_column_double(res, 3);
        int32_t _t4 = sqlite3_column_type(res, 4);
        char *_v4 = (char *)sqlite3_column_text(res, 4);
        if (_v4 != NULL) {
            t.activityID = strdup(_v4);
        } else { 
            t.activityID = NULL;
        }
        if (_t4 == SQLITE_NULL) {
            t.activityID = NULL;
        }
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheResGraphics> cacheResGraphics_load_all(bulkdata *b) {
    printf("Loading cacheResGraphics\n");
    std::vector<cacheResGraphics> out;
    sqlite3_stmt *res;
    cacheResGraphics t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheResGraphics";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.graphicID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.graphicFile = strdup(_v1);
        } else { 
            t.graphicFile = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.graphicFile = NULL;
        }
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.graphicName = strdup(_v2);
        } else { 
            t.graphicName = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.graphicName = NULL;
        }
        int32_t _t3 = sqlite3_column_type(res, 3);
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        } else { 
            t.description = NULL;
        }
        if (_t3 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.obsolete = sqlite3_column_int(res, 4);
        int32_t _t5 = sqlite3_column_type(res, 5);
        char *_v5 = (char *)sqlite3_column_text(res, 5);
        if (_v5 != NULL) {
            t.graphicType = strdup(_v5);
        } else { 
            t.graphicType = NULL;
        }
        if (_t5 == SQLITE_NULL) {
            t.graphicType = NULL;
        }
        int32_t _t6 = sqlite3_column_type(res, 6);
        char *_v6 = (char *)sqlite3_column_text(res, 6);
        if (_v6 != NULL) {
            t.collisionFile = strdup(_v6);
        } else { 
            t.collisionFile = NULL;
        }
        if (_t6 == SQLITE_NULL) {
            t.collisionFile = NULL;
        }
        int32_t _t7 = sqlite3_column_type(res, 7);
        char *_v7 = (char *)sqlite3_column_text(res, 7);
        if (_v7 != NULL) {
            t.paperdollFile = strdup(_v7);
        } else { 
            t.paperdollFile = NULL;
        }
        if (_t7 == SQLITE_NULL) {
            t.paperdollFile = NULL;
        }
        t.animationTemplate = sqlite3_column_int(res, 8);
        t.collidable = sqlite3_column_int(res, 9);
        t.explosionID = sqlite3_column_int(res, 10);
        t.directoryID = sqlite3_column_int(res, 11);
        t.graphicMinX = sqlite3_column_double(res, 12);
        t.graphicMinY = sqlite3_column_double(res, 13);
        t.graphicMinZ = sqlite3_column_double(res, 14);
        t.graphicMaxX = sqlite3_column_double(res, 15);
        t.graphicMaxY = sqlite3_column_double(res, 16);
        t.graphicMaxZ = sqlite3_column_double(res, 17);
        t.isPrototype = sqlite3_column_int(res, 18);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheInvTypes> cacheInvTypes_load_all(bulkdata *b) {
    printf("Loading cacheInvTypes\n");
    std::vector<cacheInvTypes> out;
    sqlite3_stmt *res;
    cacheInvTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvTypes";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.groupID = sqlite3_column_int(res, 1);
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.typeName = strdup(_v2);
        } else { 
            t.typeName = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.typeName = NULL;
        }
        int32_t _t3 = sqlite3_column_type(res, 3);
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        } else { 
            t.description = NULL;
        }
        if (_t3 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.graphicID = sqlite3_column_int(res, 4);
        t.radius = sqlite3_column_double(res, 5);
        t.mass = sqlite3_column_double(res, 6);
        t.volume = sqlite3_column_double(res, 7);
        t.capacity = sqlite3_column_double(res, 8);
        t.portionSize = sqlite3_column_int(res, 9);
        t.raceID = sqlite3_column_int(res, 10);
        t.basePrice = sqlite3_column_double(res, 11);
        t.published = sqlite3_column_int(res, 12);
        t.marketGroupID = sqlite3_column_int(res, 13);
        t.chanceOfDuplicating = sqlite3_column_double(res, 14);
        t.soundID = sqlite3_column_int(res, 15);
        t.iconID = sqlite3_column_int(res, 16);
        t.dataID = sqlite3_column_int(res, 17);
        t.typeNameID = sqlite3_column_int(res, 18);
        t.descriptionID = sqlite3_column_int(res, 19);
        t.copyTypeID = sqlite3_column_int(res, 20);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheResIcons> cacheResIcons_load_all(bulkdata *b) {
    printf("Loading cacheResIcons\n");
    std::vector<cacheResIcons> out;
    sqlite3_stmt *res;
    cacheResIcons t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheResIcons";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.iconID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.iconFile = strdup(_v1);
        } else { 
            t.iconFile = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.iconFile = NULL;
        }
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        } else { 
            t.description = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.obsolete = sqlite3_column_int(res, 3);
        int32_t _t4 = sqlite3_column_type(res, 4);
        char *_v4 = (char *)sqlite3_column_text(res, 4);
        if (_v4 != NULL) {
            t.iconType = strdup(_v4);
        } else { 
            t.iconType = NULL;
        }
        if (_t4 == SQLITE_NULL) {
            t.iconType = NULL;
        }
        t.directoryID = sqlite3_column_int(res, 5);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheActBillTypes> cacheActBillTypes_load_all(bulkdata *b) {
    printf("Loading cacheActBillTypes\n");
    std::vector<cacheActBillTypes> out;
    sqlite3_stmt *res;
    cacheActBillTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheActBillTypes";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.billTypeID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.billTypeName = strdup(_v1);
        } else { 
            t.billTypeName = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.billTypeName = NULL;
        }
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        } else { 
            t.description = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.billTypeNameID = sqlite3_column_int(res, 3);
        t.dataID = sqlite3_column_int(res, 4);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cachePlanetSchematicsPinMap> cachePlanetSchematicsPinMap_load_all(bulkdata *b) {
    printf("Loading cachePlanetSchematicsPinMap\n");
    std::vector<cachePlanetSchematicsPinMap> out;
    sqlite3_stmt *res;
    cachePlanetSchematicsPinMap t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cachePlanetSchematicsPinMap";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.schematicID = sqlite3_column_int(res, 0);
        t.pinTypeID = sqlite3_column_int(res, 1);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheInvContrabandTypes> cacheInvContrabandTypes_load_all(bulkdata *b) {
    printf("Loading cacheInvContrabandTypes\n");
    std::vector<cacheInvContrabandTypes> out;
    sqlite3_stmt *res;
    cacheInvContrabandTypes t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvContrabandTypes";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.factionID = sqlite3_column_int(res, 0);
        t.typeID = sqlite3_column_int(res, 1);
        t.standingLoss = sqlite3_column_double(res, 2);
        t.confiscateMinSec = sqlite3_column_double(res, 3);
        t.fineByValue = sqlite3_column_double(res, 4);
        t.attackMinSec = sqlite3_column_double(res, 5);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheInvMetaGroups> cacheInvMetaGroups_load_all(bulkdata *b) {
    printf("Loading cacheInvMetaGroups\n");
    std::vector<cacheInvMetaGroups> out;
    sqlite3_stmt *res;
    cacheInvMetaGroups t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvMetaGroups";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.metaGroupID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.metaGroupName = strdup(_v1);
        } else { 
            t.metaGroupName = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.metaGroupName = NULL;
        }
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        } else { 
            t.description = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.iconID = sqlite3_column_int(res, 3);
        t.metaGroupNameID = sqlite3_column_int(res, 4);
        t.descriptionID = sqlite3_column_int(res, 5);
        t.dataID = sqlite3_column_int(res, 6);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheCertificates> cacheCertificates_load_all(bulkdata *b) {
    printf("Loading cacheCertificates\n");
    std::vector<cacheCertificates> out;
    sqlite3_stmt *res;
    cacheCertificates t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheCertificates";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.certificateID = sqlite3_column_int(res, 0);
        t.categoryID = sqlite3_column_int(res, 1);
        t.classID = sqlite3_column_int(res, 2);
        t.grade = sqlite3_column_int(res, 3);
        t.corpID = sqlite3_column_int(res, 4);
        t.iconID = sqlite3_column_int(res, 5);
        int32_t _t6 = sqlite3_column_type(res, 6);
        char *_v6 = (char *)sqlite3_column_text(res, 6);
        if (_v6 != NULL) {
            t.description = strdup(_v6);
        } else { 
            t.description = NULL;
        }
        if (_t6 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.descriptionID = sqlite3_column_int(res, 7);
        t.dataID = sqlite3_column_int(res, 8);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheInvTypeMaterials> cacheInvTypeMaterials_load_all(bulkdata *b) {
    printf("Loading cacheInvTypeMaterials\n");
    std::vector<cacheInvTypeMaterials> out;
    sqlite3_stmt *res;
    cacheInvTypeMaterials t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheInvTypeMaterials";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.typeID = sqlite3_column_int(res, 0);
        t.materialTypeID = sqlite3_column_int(res, 1);
        t.quantity = sqlite3_column_int(res, 2);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheResSounds> cacheResSounds_load_all(bulkdata *b) {
    printf("Loading cacheResSounds\n");
    std::vector<cacheResSounds> out;
    sqlite3_stmt *res;
    cacheResSounds t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheResSounds";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.soundID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.soundFile = strdup(_v1);
        } else { 
            t.soundFile = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.soundFile = NULL;
        }
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.description = strdup(_v2);
        } else { 
            t.description = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.obsolete = sqlite3_column_int(res, 3);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

std::vector<cacheRamActivities> cacheRamActivities_load_all(bulkdata *b) {
    printf("Loading cacheRamActivities\n");
    std::vector<cacheRamActivities> out;
    sqlite3_stmt *res;
    cacheRamActivities t;
    memset(&t, 0, sizeof(t));
    char *stmt = (char *)"SELECT * from cacheRamActivities";
    int rc = sqlite3_prepare_v2(b->db, stmt, -1, &res, 0);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to execute statement: %s", sqlite3_errmsg(b->db));
    }

    int step = sqlite3_step(res);
    while(step != SQLITE_DONE && step != SQLITE_OK) {
        memset(&t, 0, sizeof(t));
        t.dirty = false;
        if (step == SQLITE_ROW) {
        t.activityID = sqlite3_column_int(res, 0);
        int32_t _t1 = sqlite3_column_type(res, 1);
        char *_v1 = (char *)sqlite3_column_text(res, 1);
        if (_v1 != NULL) {
            t.activityName = strdup(_v1);
        } else { 
            t.activityName = NULL;
        }
        if (_t1 == SQLITE_NULL) {
            t.activityName = NULL;
        }
        int32_t _t2 = sqlite3_column_type(res, 2);
        char *_v2 = (char *)sqlite3_column_text(res, 2);
        if (_v2 != NULL) {
            t.iconNo = strdup(_v2);
        } else { 
            t.iconNo = NULL;
        }
        if (_t2 == SQLITE_NULL) {
            t.iconNo = NULL;
        }
        int32_t _t3 = sqlite3_column_type(res, 3);
        char *_v3 = (char *)sqlite3_column_text(res, 3);
        if (_v3 != NULL) {
            t.description = strdup(_v3);
        } else { 
            t.description = NULL;
        }
        if (_t3 == SQLITE_NULL) {
            t.description = NULL;
        }
        t.published = sqlite3_column_int(res, 4);
        t.activityNameID = sqlite3_column_int(res, 5);
        t.descriptionID = sqlite3_column_int(res, 6);
        out.push_back(t);
        }
    step = sqlite3_step(res);
    }

    sqlite3_finalize(res);
    return out;
    }

#include <unistd.h>
cache_collection cache_load_all(bulkdata *b, loading_status_t *t) {
    cache_collection out;
    t->done = false;
    t->label = "Loading cacheShipTypes";
    out.cache_cacheShipTypes = cacheShipTypes_load_all(b);
    t->label = "Loading cacheStaOperations";
    out.cache_cacheStaOperations = cacheStaOperations_load_all(b);
    t->label = "Loading cacheRamAssemblyLineTypesCategory";
    out.cache_cacheRamAssemblyLineTypesCategory = cacheRamAssemblyLineTypesCategory_load_all(b);
    t->label = "Loading cacheInvCategories";
    out.cache_cacheInvCategories = cacheInvCategories_load_all(b);
    t->label = "Loading cacheDogmaEffects";
    out.cache_cacheDogmaEffects = cacheDogmaEffects_load_all(b);
    t->label = "Loading cacheRamCompletedStatuses";
    out.cache_cacheRamCompletedStatuses = cacheRamCompletedStatuses_load_all(b);
    t->label = "Loading cacheInvBlueprintTypes";
    out.cache_cacheInvBlueprintTypes = cacheInvBlueprintTypes_load_all(b);
    t->label = "Loading cacheRamTypeRequirements";
    out.cache_cacheRamTypeRequirements = cacheRamTypeRequirements_load_all(b);
    t->label = "Loading cacheCertificateRelationships";
    out.cache_cacheCertificateRelationships = cacheCertificateRelationships_load_all(b);
    t->label = "Loading cacheDogmaAttributes";
    out.cache_cacheDogmaAttributes = cacheDogmaAttributes_load_all(b);
    t->label = "Loading cacheRamAssemblyLineTypes";
    out.cache_cacheRamAssemblyLineTypes = cacheRamAssemblyLineTypes_load_all(b);
    t->label = "Loading cacheStaStationsStatic";
    out.cache_cacheStaStationsStatic = cacheStaStationsStatic_load_all(b);
    t->label = "Loading cacheInvGroups";
    out.cache_cacheInvGroups = cacheInvGroups_load_all(b);
    t->label = "Loading cacheInvMetaTypes";
    out.cache_cacheInvMetaTypes = cacheInvMetaTypes_load_all(b);
    t->label = "Loading cacheInvTypeReactions";
    out.cache_cacheInvTypeReactions = cacheInvTypeReactions_load_all(b);
    t->label = "Loading cacheDogmaTypeEffects";
    out.cache_cacheDogmaTypeEffects = cacheDogmaTypeEffects_load_all(b);
    t->label = "Loading cachePlanetSchematics";
    out.cache_cachePlanetSchematics = cachePlanetSchematics_load_all(b);
    t->label = "Loading cacheDogmaUnits";
    out.cache_cacheDogmaUnits = cacheDogmaUnits_load_all(b);
    t->label = "Loading cachePlanetSchematicsTypeMap";
    out.cache_cachePlanetSchematicsTypeMap = cachePlanetSchematicsTypeMap_load_all(b);
    t->label = "Loading cacheDogmaTypeAttributes";
    out.cache_cacheDogmaTypeAttributes = cacheDogmaTypeAttributes_load_all(b);
    t->label = "Loading cacheDogmaExpressions";
    out.cache_cacheDogmaExpressions = cacheDogmaExpressions_load_all(b);
    t->label = "Loading cacheRamAssemblyLineTypesGroup";
    out.cache_cacheRamAssemblyLineTypesGroup = cacheRamAssemblyLineTypesGroup_load_all(b);
    t->label = "Loading cacheResGraphics";
    out.cache_cacheResGraphics = cacheResGraphics_load_all(b);
    t->label = "Loading cacheInvTypes";
    out.cache_cacheInvTypes = cacheInvTypes_load_all(b);
    t->label = "Loading cacheResIcons";
    out.cache_cacheResIcons = cacheResIcons_load_all(b);
    t->label = "Loading cacheActBillTypes";
    out.cache_cacheActBillTypes = cacheActBillTypes_load_all(b);
    t->label = "Loading cachePlanetSchematicsPinMap";
    out.cache_cachePlanetSchematicsPinMap = cachePlanetSchematicsPinMap_load_all(b);
    t->label = "Loading cacheInvContrabandTypes";
    out.cache_cacheInvContrabandTypes = cacheInvContrabandTypes_load_all(b);
    t->label = "Loading cacheInvMetaGroups";
    out.cache_cacheInvMetaGroups = cacheInvMetaGroups_load_all(b);
    t->label = "Loading cacheCertificates";
    out.cache_cacheCertificates = cacheCertificates_load_all(b);
    t->label = "Loading cacheInvTypeMaterials";
    out.cache_cacheInvTypeMaterials = cacheInvTypeMaterials_load_all(b);
    t->label = "Loading cacheResSounds";
    out.cache_cacheResSounds = cacheResSounds_load_all(b);
    t->label = "Loading cacheRamActivities";
    out.cache_cacheRamActivities = cacheRamActivities_load_all(b);
    t->done = true;    return out;
};

uint32_t cache_count_dirty(cache_collection cc) {;
    uint32_t c = 0;
    for (uint32_t i = 0; i < cc.cache_cacheShipTypes.size(); i++) {
        if (cc.cache_cacheShipTypes[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheStaOperations.size(); i++) {
        if (cc.cache_cacheStaOperations[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheRamAssemblyLineTypesCategory.size(); i++) {
        if (cc.cache_cacheRamAssemblyLineTypesCategory[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheInvCategories.size(); i++) {
        if (cc.cache_cacheInvCategories[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheDogmaEffects.size(); i++) {
        if (cc.cache_cacheDogmaEffects[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheRamCompletedStatuses.size(); i++) {
        if (cc.cache_cacheRamCompletedStatuses[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheInvBlueprintTypes.size(); i++) {
        if (cc.cache_cacheInvBlueprintTypes[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheRamTypeRequirements.size(); i++) {
        if (cc.cache_cacheRamTypeRequirements[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheCertificateRelationships.size(); i++) {
        if (cc.cache_cacheCertificateRelationships[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheDogmaAttributes.size(); i++) {
        if (cc.cache_cacheDogmaAttributes[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheRamAssemblyLineTypes.size(); i++) {
        if (cc.cache_cacheRamAssemblyLineTypes[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheStaStationsStatic.size(); i++) {
        if (cc.cache_cacheStaStationsStatic[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheInvGroups.size(); i++) {
        if (cc.cache_cacheInvGroups[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheInvMetaTypes.size(); i++) {
        if (cc.cache_cacheInvMetaTypes[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheInvTypeReactions.size(); i++) {
        if (cc.cache_cacheInvTypeReactions[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheDogmaTypeEffects.size(); i++) {
        if (cc.cache_cacheDogmaTypeEffects[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cachePlanetSchematics.size(); i++) {
        if (cc.cache_cachePlanetSchematics[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheDogmaUnits.size(); i++) {
        if (cc.cache_cacheDogmaUnits[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cachePlanetSchematicsTypeMap.size(); i++) {
        if (cc.cache_cachePlanetSchematicsTypeMap[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheDogmaTypeAttributes.size(); i++) {
        if (cc.cache_cacheDogmaTypeAttributes[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheDogmaExpressions.size(); i++) {
        if (cc.cache_cacheDogmaExpressions[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheRamAssemblyLineTypesGroup.size(); i++) {
        if (cc.cache_cacheRamAssemblyLineTypesGroup[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheResGraphics.size(); i++) {
        if (cc.cache_cacheResGraphics[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheInvTypes.size(); i++) {
        if (cc.cache_cacheInvTypes[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheResIcons.size(); i++) {
        if (cc.cache_cacheResIcons[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheActBillTypes.size(); i++) {
        if (cc.cache_cacheActBillTypes[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cachePlanetSchematicsPinMap.size(); i++) {
        if (cc.cache_cachePlanetSchematicsPinMap[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheInvContrabandTypes.size(); i++) {
        if (cc.cache_cacheInvContrabandTypes[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheInvMetaGroups.size(); i++) {
        if (cc.cache_cacheInvMetaGroups[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheCertificates.size(); i++) {
        if (cc.cache_cacheCertificates[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheInvTypeMaterials.size(); i++) {
        if (cc.cache_cacheInvTypeMaterials[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheResSounds.size(); i++) {
        if (cc.cache_cacheResSounds[i].dirty) c += 1;
    }
    for (uint32_t i = 0; i < cc.cache_cacheRamActivities.size(); i++) {
        if (cc.cache_cacheRamActivities[i].dirty) c += 1;
    }
    return c;
};

cacheShipTypes* cache_get_cacheShipTypes_by_shipTypeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheShipTypes.size(); i++) {
        if (cc->cache_cacheShipTypes[i].shipTypeID == ID) {
            return &cc->cache_cacheShipTypes[i];
        }
    }
    return NULL;
};

cacheStaOperations* cache_get_cacheStaOperations_by_activityID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheStaOperations.size(); i++) {
        if (cc->cache_cacheStaOperations[i].activityID == ID) {
            return &cc->cache_cacheStaOperations[i];
        }
    }
    return NULL;
};

cacheRamAssemblyLineTypesCategory* cache_get_cacheRamAssemblyLineTypesCategory_by_assemblyLineTypeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheRamAssemblyLineTypesCategory.size(); i++) {
        if (cc->cache_cacheRamAssemblyLineTypesCategory[i].assemblyLineTypeID == ID) {
            return &cc->cache_cacheRamAssemblyLineTypesCategory[i];
        }
    }
    return NULL;
};

cacheInvCategories* cache_get_cacheInvCategories_by_categoryID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheInvCategories.size(); i++) {
        if (cc->cache_cacheInvCategories[i].categoryID == ID) {
            return &cc->cache_cacheInvCategories[i];
        }
    }
    return NULL;
};

cacheDogmaEffects* cache_get_cacheDogmaEffects_by_effectID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheDogmaEffects.size(); i++) {
        if (cc->cache_cacheDogmaEffects[i].effectID == ID) {
            return &cc->cache_cacheDogmaEffects[i];
        }
    }
    return NULL;
};

cacheRamCompletedStatuses* cache_get_cacheRamCompletedStatuses_by_completedStatus(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheRamCompletedStatuses.size(); i++) {
        if (cc->cache_cacheRamCompletedStatuses[i].completedStatus == ID) {
            return &cc->cache_cacheRamCompletedStatuses[i];
        }
    }
    return NULL;
};

cacheInvBlueprintTypes* cache_get_cacheInvBlueprintTypes_by_blueprintTypeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheInvBlueprintTypes.size(); i++) {
        if (cc->cache_cacheInvBlueprintTypes[i].blueprintTypeID == ID) {
            return &cc->cache_cacheInvBlueprintTypes[i];
        }
    }
    return NULL;
};

cacheRamTypeRequirements* cache_get_cacheRamTypeRequirements_by_typeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheRamTypeRequirements.size(); i++) {
        if (cc->cache_cacheRamTypeRequirements[i].typeID == ID) {
            return &cc->cache_cacheRamTypeRequirements[i];
        }
    }
    return NULL;
};

cacheCertificateRelationships* cache_get_cacheCertificateRelationships_by_relationshipID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheCertificateRelationships.size(); i++) {
        if (cc->cache_cacheCertificateRelationships[i].relationshipID == ID) {
            return &cc->cache_cacheCertificateRelationships[i];
        }
    }
    return NULL;
};

cacheDogmaAttributes* cache_get_cacheDogmaAttributes_by_attributeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheDogmaAttributes.size(); i++) {
        if (cc->cache_cacheDogmaAttributes[i].attributeID == ID) {
            return &cc->cache_cacheDogmaAttributes[i];
        }
    }
    return NULL;
};

cacheRamAssemblyLineTypes* cache_get_cacheRamAssemblyLineTypes_by_assemblyLineTypeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheRamAssemblyLineTypes.size(); i++) {
        if (cc->cache_cacheRamAssemblyLineTypes[i].assemblyLineTypeID == ID) {
            return &cc->cache_cacheRamAssemblyLineTypes[i];
        }
    }
    return NULL;
};

cacheStaStationsStatic* cache_get_cacheStaStationsStatic_by_stationID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheStaStationsStatic.size(); i++) {
        if (cc->cache_cacheStaStationsStatic[i].stationID == ID) {
            return &cc->cache_cacheStaStationsStatic[i];
        }
    }
    return NULL;
};

cacheInvGroups* cache_get_cacheInvGroups_by_groupID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheInvGroups.size(); i++) {
        if (cc->cache_cacheInvGroups[i].groupID == ID) {
            return &cc->cache_cacheInvGroups[i];
        }
    }
    return NULL;
};

cacheInvMetaTypes* cache_get_cacheInvMetaTypes_by_typeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheInvMetaTypes.size(); i++) {
        if (cc->cache_cacheInvMetaTypes[i].typeID == ID) {
            return &cc->cache_cacheInvMetaTypes[i];
        }
    }
    return NULL;
};

cacheInvTypeReactions* cache_get_cacheInvTypeReactions_by_reactionTypeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheInvTypeReactions.size(); i++) {
        if (cc->cache_cacheInvTypeReactions[i].reactionTypeID == ID) {
            return &cc->cache_cacheInvTypeReactions[i];
        }
    }
    return NULL;
};

cacheDogmaTypeEffects* cache_get_cacheDogmaTypeEffects_by_typeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheDogmaTypeEffects.size(); i++) {
        if (cc->cache_cacheDogmaTypeEffects[i].typeID == ID) {
            return &cc->cache_cacheDogmaTypeEffects[i];
        }
    }
    return NULL;
};

cachePlanetSchematics* cache_get_cachePlanetSchematics_by_schematicID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cachePlanetSchematics.size(); i++) {
        if (cc->cache_cachePlanetSchematics[i].schematicID == ID) {
            return &cc->cache_cachePlanetSchematics[i];
        }
    }
    return NULL;
};

cacheDogmaUnits* cache_get_cacheDogmaUnits_by_unitID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheDogmaUnits.size(); i++) {
        if (cc->cache_cacheDogmaUnits[i].unitID == ID) {
            return &cc->cache_cacheDogmaUnits[i];
        }
    }
    return NULL;
};

cachePlanetSchematicsTypeMap* cache_get_cachePlanetSchematicsTypeMap_by_schematicID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cachePlanetSchematicsTypeMap.size(); i++) {
        if (cc->cache_cachePlanetSchematicsTypeMap[i].schematicID == ID) {
            return &cc->cache_cachePlanetSchematicsTypeMap[i];
        }
    }
    return NULL;
};

cacheDogmaTypeAttributes* cache_get_cacheDogmaTypeAttributes_by_typeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheDogmaTypeAttributes.size(); i++) {
        if (cc->cache_cacheDogmaTypeAttributes[i].typeID == ID) {
            return &cc->cache_cacheDogmaTypeAttributes[i];
        }
    }
    return NULL;
};

cacheDogmaExpressions* cache_get_cacheDogmaExpressions_by_expressionID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheDogmaExpressions.size(); i++) {
        if (cc->cache_cacheDogmaExpressions[i].expressionID == ID) {
            return &cc->cache_cacheDogmaExpressions[i];
        }
    }
    return NULL;
};

cacheRamAssemblyLineTypesGroup* cache_get_cacheRamAssemblyLineTypesGroup_by_assemblyLineTypeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheRamAssemblyLineTypesGroup.size(); i++) {
        if (cc->cache_cacheRamAssemblyLineTypesGroup[i].assemblyLineTypeID == ID) {
            return &cc->cache_cacheRamAssemblyLineTypesGroup[i];
        }
    }
    return NULL;
};

cacheResGraphics* cache_get_cacheResGraphics_by_graphicID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheResGraphics.size(); i++) {
        if (cc->cache_cacheResGraphics[i].graphicID == ID) {
            return &cc->cache_cacheResGraphics[i];
        }
    }
    return NULL;
};

cacheInvTypes* cache_get_cacheInvTypes_by_typeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheInvTypes.size(); i++) {
        if (cc->cache_cacheInvTypes[i].typeID == ID) {
            return &cc->cache_cacheInvTypes[i];
        }
    }
    return NULL;
};

cacheResIcons* cache_get_cacheResIcons_by_iconID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheResIcons.size(); i++) {
        if (cc->cache_cacheResIcons[i].iconID == ID) {
            return &cc->cache_cacheResIcons[i];
        }
    }
    return NULL;
};

cacheActBillTypes* cache_get_cacheActBillTypes_by_billTypeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheActBillTypes.size(); i++) {
        if (cc->cache_cacheActBillTypes[i].billTypeID == ID) {
            return &cc->cache_cacheActBillTypes[i];
        }
    }
    return NULL;
};

cachePlanetSchematicsPinMap* cache_get_cachePlanetSchematicsPinMap_by_schematicID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cachePlanetSchematicsPinMap.size(); i++) {
        if (cc->cache_cachePlanetSchematicsPinMap[i].schematicID == ID) {
            return &cc->cache_cachePlanetSchematicsPinMap[i];
        }
    }
    return NULL;
};

cacheInvContrabandTypes* cache_get_cacheInvContrabandTypes_by_factionID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheInvContrabandTypes.size(); i++) {
        if (cc->cache_cacheInvContrabandTypes[i].factionID == ID) {
            return &cc->cache_cacheInvContrabandTypes[i];
        }
    }
    return NULL;
};

cacheInvMetaGroups* cache_get_cacheInvMetaGroups_by_metaGroupID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheInvMetaGroups.size(); i++) {
        if (cc->cache_cacheInvMetaGroups[i].metaGroupID == ID) {
            return &cc->cache_cacheInvMetaGroups[i];
        }
    }
    return NULL;
};

cacheCertificates* cache_get_cacheCertificates_by_certificateID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheCertificates.size(); i++) {
        if (cc->cache_cacheCertificates[i].certificateID == ID) {
            return &cc->cache_cacheCertificates[i];
        }
    }
    return NULL;
};

cacheInvTypeMaterials* cache_get_cacheInvTypeMaterials_by_typeID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheInvTypeMaterials.size(); i++) {
        if (cc->cache_cacheInvTypeMaterials[i].typeID == ID) {
            return &cc->cache_cacheInvTypeMaterials[i];
        }
    }
    return NULL;
};

cacheResSounds* cache_get_cacheResSounds_by_soundID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheResSounds.size(); i++) {
        if (cc->cache_cacheResSounds[i].soundID == ID) {
            return &cc->cache_cacheResSounds[i];
        }
    }
    return NULL;
};

cacheRamActivities* cache_get_cacheRamActivities_by_activityID(cache_collection *cc, uint32_t ID) {
    for (uint32_t i = 0; i < cc->cache_cacheRamActivities.size(); i++) {
        if (cc->cache_cacheRamActivities[i].activityID == ID) {
            return &cc->cache_cacheRamActivities[i];
        }
    }
    return NULL;
};

