/* Generated by codegen.py
 * DO NOT EDIT
 */


#include "cache_types.h"

#include <string.h>

#include "bulkdata.h"

#include <list>

#include "imgui.h"

#include <string>
void cacheShipTypes_save(cacheShipTypes *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheShipTypes SET ");
    sql.append("shipTypeID = ");
sql.append(std::to_string(data->shipTypeID));
sql.append(", ");
    sql.append("weaponTypeID = ");
sql.append(std::to_string(data->weaponTypeID));
sql.append(", ");
    sql.append("miningTypeID = ");
sql.append(std::to_string(data->miningTypeID));
sql.append(", ");
    sql.append("skillTypeID = ");
sql.append(std::to_string(data->skillTypeID));
   sql.append(" WHERE shipTypeID = ");
   sql.append(std::to_string(data->shipTypeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheStaOperations_save(cacheStaOperations *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheStaOperations SET ");
    sql.append("activityID = ");
sql.append(std::to_string(data->activityID));
sql.append(", ");
    sql.append("operationID = ");
sql.append(std::to_string(data->operationID));
sql.append(", ");
    sql.append("operationName = ");
sql.append("'");
sql.append(data->operationName);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("fringe = ");
sql.append(std::to_string(data->fringe));
sql.append(", ");
    sql.append("corridor = ");
sql.append(std::to_string(data->corridor));
sql.append(", ");
    sql.append("hub = ");
sql.append(std::to_string(data->hub));
sql.append(", ");
    sql.append("border = ");
sql.append(std::to_string(data->border));
sql.append(", ");
    sql.append("ratio = ");
sql.append(std::to_string(data->ratio));
sql.append(", ");
    sql.append("caldariStationTypeID = ");
sql.append(std::to_string(data->caldariStationTypeID));
sql.append(", ");
    sql.append("minmatarStationTypeID = ");
sql.append(std::to_string(data->minmatarStationTypeID));
sql.append(", ");
    sql.append("amarrStationTypeID = ");
sql.append(std::to_string(data->amarrStationTypeID));
sql.append(", ");
    sql.append("gallenteStationTypeID = ");
sql.append(std::to_string(data->gallenteStationTypeID));
sql.append(", ");
    sql.append("joveStationTypeID = ");
sql.append(std::to_string(data->joveStationTypeID));
sql.append(", ");
    sql.append("operationNameID = ");
sql.append(std::to_string(data->operationNameID));
sql.append(", ");
    sql.append("descriptionID = ");
sql.append(std::to_string(data->descriptionID));
sql.append(", ");
    sql.append("serviceMask = ");
sql.append(std::to_string(data->serviceMask));
   sql.append(" WHERE activityID = ");
   sql.append(std::to_string(data->activityID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheRamAssemblyLineTypesCategory_save(cacheRamAssemblyLineTypesCategory *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheRamAssemblyLineTypesCategory SET ");
    sql.append("assemblyLineTypeID = ");
sql.append(std::to_string(data->assemblyLineTypeID));
sql.append(", ");
    sql.append("categoryID = ");
sql.append(std::to_string(data->categoryID));
sql.append(", ");
    sql.append("timeMultiplier = ");
sql.append(std::to_string(data->timeMultiplier));
sql.append(", ");
    sql.append("materialMultiplier = ");
sql.append(std::to_string(data->materialMultiplier));
sql.append(", ");
    sql.append("activityID = ");
sql.append(data->activityID);
   sql.append(" WHERE assemblyLineTypeID = ");
   sql.append(std::to_string(data->assemblyLineTypeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheInvCategories_save(cacheInvCategories *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheInvCategories SET ");
    sql.append("categoryID = ");
sql.append(std::to_string(data->categoryID));
sql.append(", ");
    sql.append("categoryName = ");
sql.append("'");
sql.append(data->categoryName);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("published = ");
sql.append(std::to_string(data->published));
sql.append(", ");
    sql.append("iconID = ");
sql.append(std::to_string(data->iconID));
sql.append(", ");
    sql.append("categoryNameID = ");
sql.append(std::to_string(data->categoryNameID));
sql.append(", ");
    sql.append("dataID = ");
sql.append(std::to_string(data->dataID));
   sql.append(" WHERE categoryID = ");
   sql.append(std::to_string(data->categoryID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheDogmaEffects_save(cacheDogmaEffects *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheDogmaEffects SET ");
    sql.append("effectID = ");
sql.append(std::to_string(data->effectID));
sql.append(", ");
    sql.append("effectName = ");
sql.append("'");
sql.append(data->effectName);
sql.append("'");
sql.append(", ");
    sql.append("effectCategory = ");
sql.append(std::to_string(data->effectCategory));
sql.append(", ");
    sql.append("preExpression = ");
sql.append(std::to_string(data->preExpression));
sql.append(", ");
    sql.append("postExpression = ");
sql.append(std::to_string(data->postExpression));
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("guid = ");
sql.append("'");
sql.append(data->guid);
sql.append("'");
sql.append(", ");
    sql.append("isOffensive = ");
sql.append(std::to_string(data->isOffensive));
sql.append(", ");
    sql.append("isAssistance = ");
sql.append(std::to_string(data->isAssistance));
sql.append(", ");
    sql.append("durationAttributeID = ");
sql.append(std::to_string(data->durationAttributeID));
sql.append(", ");
    sql.append("trackingSpeedAttributeID = ");
sql.append(std::to_string(data->trackingSpeedAttributeID));
sql.append(", ");
    sql.append("dischargeAttributeID = ");
sql.append(std::to_string(data->dischargeAttributeID));
sql.append(", ");
    sql.append("rangeAttributeID = ");
sql.append(std::to_string(data->rangeAttributeID));
sql.append(", ");
    sql.append("falloffAttributeID = ");
sql.append(std::to_string(data->falloffAttributeID));
sql.append(", ");
    sql.append("disallowAutoRepeat = ");
sql.append(std::to_string(data->disallowAutoRepeat));
sql.append(", ");
    sql.append("published = ");
sql.append(std::to_string(data->published));
sql.append(", ");
    sql.append("displayName = ");
sql.append("'");
sql.append(data->displayName);
sql.append("'");
sql.append(", ");
    sql.append("isWarpSafe = ");
sql.append(std::to_string(data->isWarpSafe));
sql.append(", ");
    sql.append("rangeChance = ");
sql.append(std::to_string(data->rangeChance));
sql.append(", ");
    sql.append("electronicChance = ");
sql.append(std::to_string(data->electronicChance));
sql.append(", ");
    sql.append("propulsionChance = ");
sql.append(std::to_string(data->propulsionChance));
sql.append(", ");
    sql.append("distribution = ");
sql.append(std::to_string(data->distribution));
sql.append(", ");
    sql.append("sfxName = ");
sql.append("'");
sql.append(data->sfxName);
sql.append("'");
sql.append(", ");
    sql.append("npcUsageChanceAttributeID = ");
sql.append(std::to_string(data->npcUsageChanceAttributeID));
sql.append(", ");
    sql.append("npcActivationChanceAttributeID = ");
sql.append(std::to_string(data->npcActivationChanceAttributeID));
sql.append(", ");
    sql.append("fittingUsageChanceAttributeID = ");
sql.append(std::to_string(data->fittingUsageChanceAttributeID));
sql.append(", ");
    sql.append("iconID = ");
sql.append(std::to_string(data->iconID));
sql.append(", ");
    sql.append("displayNameID = ");
sql.append(std::to_string(data->displayNameID));
sql.append(", ");
    sql.append("descriptionID = ");
sql.append(std::to_string(data->descriptionID));
sql.append(", ");
    sql.append("dataID = ");
sql.append(std::to_string(data->dataID));
   sql.append(" WHERE effectID = ");
   sql.append(std::to_string(data->effectID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheRamCompletedStatuses_save(cacheRamCompletedStatuses *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheRamCompletedStatuses SET ");
    sql.append("completedStatus = ");
sql.append(std::to_string(data->completedStatus));
sql.append(", ");
    sql.append("completedStatusText = ");
sql.append("'");
sql.append(data->completedStatusText);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("completedStatusTextID = ");
sql.append(std::to_string(data->completedStatusTextID));
   sql.append(" WHERE completedStatus = ");
   sql.append(std::to_string(data->completedStatus));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheInvBlueprintTypes_save(cacheInvBlueprintTypes *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheInvBlueprintTypes SET ");
    sql.append("blueprintTypeID = ");
sql.append(std::to_string(data->blueprintTypeID));
sql.append(", ");
    sql.append("parentBlueprintTypeID = ");
sql.append(std::to_string(data->parentBlueprintTypeID));
sql.append(", ");
    sql.append("productTypeID = ");
sql.append(std::to_string(data->productTypeID));
sql.append(", ");
    sql.append("productionTime = ");
sql.append(std::to_string(data->productionTime));
sql.append(", ");
    sql.append("techLevel = ");
sql.append(std::to_string(data->techLevel));
sql.append(", ");
    sql.append("researchProductivityTime = ");
sql.append(std::to_string(data->researchProductivityTime));
sql.append(", ");
    sql.append("researchMaterialTime = ");
sql.append(std::to_string(data->researchMaterialTime));
sql.append(", ");
    sql.append("researchCopyTime = ");
sql.append(std::to_string(data->researchCopyTime));
sql.append(", ");
    sql.append("researchTechTime = ");
sql.append(std::to_string(data->researchTechTime));
sql.append(", ");
    sql.append("productivityModifier = ");
sql.append(std::to_string(data->productivityModifier));
sql.append(", ");
    sql.append("materialModifier = ");
sql.append(std::to_string(data->materialModifier));
sql.append(", ");
    sql.append("wasteFactor = ");
sql.append(std::to_string(data->wasteFactor));
sql.append(", ");
    sql.append("chanceOfReverseEngineering = ");
sql.append(std::to_string(data->chanceOfReverseEngineering));
sql.append(", ");
    sql.append("maxProductionLimit = ");
sql.append(std::to_string(data->maxProductionLimit));
   sql.append(" WHERE blueprintTypeID = ");
   sql.append(std::to_string(data->blueprintTypeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheRamTypeRequirements_save(cacheRamTypeRequirements *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheRamTypeRequirements SET ");
    sql.append("typeID = ");
sql.append(std::to_string(data->typeID));
sql.append(", ");
    sql.append("activityID = ");
sql.append(std::to_string(data->activityID));
sql.append(", ");
    sql.append("requiredTypeID = ");
sql.append(std::to_string(data->requiredTypeID));
sql.append(", ");
    sql.append("quantity = ");
sql.append(std::to_string(data->quantity));
sql.append(", ");
    sql.append("damagePerJob = ");
sql.append(std::to_string(data->damagePerJob));
sql.append(", ");
    sql.append("recycle = ");
sql.append(std::to_string(data->recycle));
   sql.append(" WHERE typeID = ");
   sql.append(std::to_string(data->typeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheCertificateRelationships_save(cacheCertificateRelationships *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheCertificateRelationships SET ");
    sql.append("relationshipID = ");
sql.append(std::to_string(data->relationshipID));
sql.append(", ");
    sql.append("parentID = ");
sql.append(std::to_string(data->parentID));
sql.append(", ");
    sql.append("parentTypeID = ");
sql.append(std::to_string(data->parentTypeID));
sql.append(", ");
    sql.append("parentLevel = ");
sql.append(std::to_string(data->parentLevel));
sql.append(", ");
    sql.append("childID = ");
sql.append(std::to_string(data->childID));
sql.append(", ");
    sql.append("childTypeID = ");
sql.append(std::to_string(data->childTypeID));
   sql.append(" WHERE relationshipID = ");
   sql.append(std::to_string(data->relationshipID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheDogmaAttributes_save(cacheDogmaAttributes *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheDogmaAttributes SET ");
    sql.append("attributeID = ");
sql.append(std::to_string(data->attributeID));
sql.append(", ");
    sql.append("attributeName = ");
sql.append("'");
sql.append(data->attributeName);
sql.append("'");
sql.append(", ");
    sql.append("attributeCategory = ");
sql.append(std::to_string(data->attributeCategory));
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("maxAttributeID = ");
sql.append(std::to_string(data->maxAttributeID));
sql.append(", ");
    sql.append("attributeIdx = ");
sql.append(std::to_string(data->attributeIdx));
sql.append(", ");
    sql.append("chargeRechargeTimeID = ");
sql.append(std::to_string(data->chargeRechargeTimeID));
sql.append(", ");
    sql.append("defaultValue = ");
sql.append(std::to_string(data->defaultValue));
sql.append(", ");
    sql.append("published = ");
sql.append(std::to_string(data->published));
sql.append(", ");
    sql.append("displayName = ");
sql.append("'");
sql.append(data->displayName);
sql.append("'");
sql.append(", ");
    sql.append("unitID = ");
sql.append(std::to_string(data->unitID));
sql.append(", ");
    sql.append("stackable = ");
sql.append(std::to_string(data->stackable));
sql.append(", ");
    sql.append("highIsGood = ");
sql.append(std::to_string(data->highIsGood));
sql.append(", ");
    sql.append("categoryID = ");
sql.append(std::to_string(data->categoryID));
sql.append(", ");
    sql.append("iconID = ");
sql.append(std::to_string(data->iconID));
sql.append(", ");
    sql.append("displayNameID = ");
sql.append(std::to_string(data->displayNameID));
sql.append(", ");
    sql.append("dataID = ");
sql.append(std::to_string(data->dataID));
   sql.append(" WHERE attributeID = ");
   sql.append(std::to_string(data->attributeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheRamAssemblyLineTypes_save(cacheRamAssemblyLineTypes *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheRamAssemblyLineTypes SET ");
    sql.append("assemblyLineTypeID = ");
sql.append(std::to_string(data->assemblyLineTypeID));
sql.append(", ");
    sql.append("assemblyLineTypeName = ");
sql.append("'");
sql.append(data->assemblyLineTypeName);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("baseTimeMultiplier = ");
sql.append(std::to_string(data->baseTimeMultiplier));
sql.append(", ");
    sql.append("baseMaterialMultiplier = ");
sql.append(std::to_string(data->baseMaterialMultiplier));
sql.append(", ");
    sql.append("volume = ");
sql.append(std::to_string(data->volume));
sql.append(", ");
    sql.append("activityID = ");
sql.append(std::to_string(data->activityID));
sql.append(", ");
    sql.append("minCostPerHour = ");
sql.append(std::to_string(data->minCostPerHour));
   sql.append(" WHERE assemblyLineTypeID = ");
   sql.append(std::to_string(data->assemblyLineTypeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheStaStationsStatic_save(cacheStaStationsStatic *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheStaStationsStatic SET ");
    sql.append("stationID = ");
sql.append(std::to_string(data->stationID));
sql.append(", ");
    sql.append("stationName = ");
sql.append("'");
sql.append(data->stationName);
sql.append("'");
sql.append(", ");
    sql.append("x = ");
sql.append(std::to_string(data->x));
sql.append(", ");
    sql.append("y = ");
sql.append(std::to_string(data->y));
sql.append(", ");
    sql.append("z = ");
sql.append(std::to_string(data->z));
sql.append(", ");
    sql.append("stationTypeID = ");
sql.append(std::to_string(data->stationTypeID));
sql.append(", ");
    sql.append("solarSystemID = ");
sql.append(std::to_string(data->solarSystemID));
   sql.append(" WHERE stationID = ");
   sql.append(std::to_string(data->stationID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheInvGroups_save(cacheInvGroups *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheInvGroups SET ");
    sql.append("groupID = ");
sql.append(std::to_string(data->groupID));
sql.append(", ");
    sql.append("categoryID = ");
sql.append(std::to_string(data->categoryID));
sql.append(", ");
    sql.append("groupName = ");
sql.append("'");
sql.append(data->groupName);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("useBasePrice = ");
sql.append(std::to_string(data->useBasePrice));
sql.append(", ");
    sql.append("allowManufacture = ");
sql.append(std::to_string(data->allowManufacture));
sql.append(", ");
    sql.append("allowRecycler = ");
sql.append(std::to_string(data->allowRecycler));
sql.append(", ");
    sql.append("anchored = ");
sql.append(std::to_string(data->anchored));
sql.append(", ");
    sql.append("anchorable = ");
sql.append(std::to_string(data->anchorable));
sql.append(", ");
    sql.append("fittableNonSingleton = ");
sql.append(std::to_string(data->fittableNonSingleton));
sql.append(", ");
    sql.append("published = ");
sql.append(std::to_string(data->published));
sql.append(", ");
    sql.append("iconID = ");
sql.append(std::to_string(data->iconID));
sql.append(", ");
    sql.append("groupNameID = ");
sql.append(std::to_string(data->groupNameID));
sql.append(", ");
    sql.append("dataID = ");
sql.append(std::to_string(data->dataID));
   sql.append(" WHERE groupID = ");
   sql.append(std::to_string(data->groupID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheInvMetaTypes_save(cacheInvMetaTypes *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheInvMetaTypes SET ");
    sql.append("typeID = ");
sql.append(std::to_string(data->typeID));
sql.append(", ");
    sql.append("parentTypeID = ");
sql.append(std::to_string(data->parentTypeID));
sql.append(", ");
    sql.append("metaGroupID = ");
sql.append(std::to_string(data->metaGroupID));
   sql.append(" WHERE typeID = ");
   sql.append(std::to_string(data->typeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheInvTypeReactions_save(cacheInvTypeReactions *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheInvTypeReactions SET ");
    sql.append("reactionTypeID = ");
sql.append(std::to_string(data->reactionTypeID));
sql.append(", ");
    sql.append("input = ");
sql.append(std::to_string(data->input));
sql.append(", ");
    sql.append("typeID = ");
sql.append(std::to_string(data->typeID));
sql.append(", ");
    sql.append("quantity = ");
sql.append(std::to_string(data->quantity));
   sql.append(" WHERE reactionTypeID = ");
   sql.append(std::to_string(data->reactionTypeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheDogmaTypeEffects_save(cacheDogmaTypeEffects *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheDogmaTypeEffects SET ");
    sql.append("typeID = ");
sql.append(std::to_string(data->typeID));
sql.append(", ");
    sql.append("effectID = ");
sql.append(std::to_string(data->effectID));
sql.append(", ");
    sql.append("isDefault = ");
sql.append(std::to_string(data->isDefault));
   sql.append(" WHERE typeID = ");
   sql.append(std::to_string(data->typeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cachePlanetSchematics_save(cachePlanetSchematics *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cachePlanetSchematics SET ");
    sql.append("schematicID = ");
sql.append(std::to_string(data->schematicID));
sql.append(", ");
    sql.append("schematicName = ");
sql.append("'");
sql.append(data->schematicName);
sql.append("'");
sql.append(", ");
    sql.append("cycleTime = ");
sql.append(std::to_string(data->cycleTime));
sql.append(", ");
    sql.append("schematicNameID = ");
sql.append(std::to_string(data->schematicNameID));
sql.append(", ");
    sql.append("dataID = ");
sql.append(std::to_string(data->dataID));
   sql.append(" WHERE schematicID = ");
   sql.append(std::to_string(data->schematicID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheDogmaUnits_save(cacheDogmaUnits *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheDogmaUnits SET ");
    sql.append("unitID = ");
sql.append(std::to_string(data->unitID));
sql.append(", ");
    sql.append("unitName = ");
sql.append("'");
sql.append(data->unitName);
sql.append("'");
sql.append(", ");
    sql.append("displayName = ");
sql.append("'");
sql.append(data->displayName);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("displayNameID = ");
sql.append(std::to_string(data->displayNameID));
sql.append(", ");
    sql.append("descriptionID = ");
sql.append(std::to_string(data->descriptionID));
sql.append(", ");
    sql.append("dataID = ");
sql.append(std::to_string(data->dataID));
   sql.append(" WHERE unitID = ");
   sql.append(std::to_string(data->unitID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cachePlanetSchematicsTypeMap_save(cachePlanetSchematicsTypeMap *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cachePlanetSchematicsTypeMap SET ");
    sql.append("schematicID = ");
sql.append(std::to_string(data->schematicID));
sql.append(", ");
    sql.append("typeID = ");
sql.append(std::to_string(data->typeID));
sql.append(", ");
    sql.append("isInput = ");
sql.append(std::to_string(data->isInput));
sql.append(", ");
    sql.append("quantity = ");
sql.append(std::to_string(data->quantity));
   sql.append(" WHERE schematicID = ");
   sql.append(std::to_string(data->schematicID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheDogmaTypeAttributes_save(cacheDogmaTypeAttributes *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheDogmaTypeAttributes SET ");
    sql.append("typeID = ");
sql.append(std::to_string(data->typeID));
sql.append(", ");
    sql.append("attributeID = ");
sql.append(std::to_string(data->attributeID));
sql.append(", ");
    sql.append("value = ");
sql.append(std::to_string(data->value));
   sql.append(" WHERE typeID = ");
   sql.append(std::to_string(data->typeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheDogmaExpressions_save(cacheDogmaExpressions *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheDogmaExpressions SET ");
    sql.append("expressionID = ");
sql.append(std::to_string(data->expressionID));
sql.append(", ");
    sql.append("operandID = ");
sql.append(std::to_string(data->operandID));
sql.append(", ");
    sql.append("arg1 = ");
sql.append(std::to_string(data->arg1));
sql.append(", ");
    sql.append("arg2 = ");
sql.append(std::to_string(data->arg2));
sql.append(", ");
    sql.append("expressionValue = ");
sql.append("'");
sql.append(data->expressionValue);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("expressionName = ");
sql.append("'");
sql.append(data->expressionName);
sql.append("'");
sql.append(", ");
    sql.append("expressionTypeID = ");
sql.append(std::to_string(data->expressionTypeID));
sql.append(", ");
    sql.append("expressionGroupID = ");
sql.append(std::to_string(data->expressionGroupID));
sql.append(", ");
    sql.append("expressionAttributeID = ");
sql.append(std::to_string(data->expressionAttributeID));
   sql.append(" WHERE expressionID = ");
   sql.append(std::to_string(data->expressionID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheRamAssemblyLineTypesGroup_save(cacheRamAssemblyLineTypesGroup *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheRamAssemblyLineTypesGroup SET ");
    sql.append("assemblyLineTypeID = ");
sql.append(std::to_string(data->assemblyLineTypeID));
sql.append(", ");
    sql.append("groupID = ");
sql.append(std::to_string(data->groupID));
sql.append(", ");
    sql.append("timeMultiplier = ");
sql.append(std::to_string(data->timeMultiplier));
sql.append(", ");
    sql.append("materialMultiplier = ");
sql.append(std::to_string(data->materialMultiplier));
sql.append(", ");
    sql.append("activityID = ");
sql.append(data->activityID);
   sql.append(" WHERE assemblyLineTypeID = ");
   sql.append(std::to_string(data->assemblyLineTypeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheResGraphics_save(cacheResGraphics *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheResGraphics SET ");
    sql.append("graphicID = ");
sql.append(std::to_string(data->graphicID));
sql.append(", ");
    sql.append("graphicFile = ");
sql.append("'");
sql.append(data->graphicFile);
sql.append("'");
sql.append(", ");
    sql.append("graphicName = ");
sql.append("'");
sql.append(data->graphicName);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("obsolete = ");
sql.append(std::to_string(data->obsolete));
sql.append(", ");
    sql.append("graphicType = ");
sql.append("'");
sql.append(data->graphicType);
sql.append("'");
sql.append(", ");
    sql.append("collisionFile = ");
sql.append("'");
sql.append(data->collisionFile);
sql.append("'");
sql.append(", ");
    sql.append("paperdollFile = ");
sql.append("'");
sql.append(data->paperdollFile);
sql.append("'");
sql.append(", ");
    sql.append("animationTemplate = ");
sql.append(std::to_string(data->animationTemplate));
sql.append(", ");
    sql.append("collidable = ");
sql.append(std::to_string(data->collidable));
sql.append(", ");
    sql.append("explosionID = ");
sql.append(std::to_string(data->explosionID));
sql.append(", ");
    sql.append("directoryID = ");
sql.append(std::to_string(data->directoryID));
sql.append(", ");
    sql.append("graphicMinX = ");
sql.append(std::to_string(data->graphicMinX));
sql.append(", ");
    sql.append("graphicMinY = ");
sql.append(std::to_string(data->graphicMinY));
sql.append(", ");
    sql.append("graphicMinZ = ");
sql.append(std::to_string(data->graphicMinZ));
sql.append(", ");
    sql.append("graphicMaxX = ");
sql.append(std::to_string(data->graphicMaxX));
sql.append(", ");
    sql.append("graphicMaxY = ");
sql.append(std::to_string(data->graphicMaxY));
sql.append(", ");
    sql.append("graphicMaxZ = ");
sql.append(std::to_string(data->graphicMaxZ));
sql.append(", ");
    sql.append("isPrototype = ");
sql.append(std::to_string(data->isPrototype));
   sql.append(" WHERE graphicID = ");
   sql.append(std::to_string(data->graphicID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheInvTypes_save(cacheInvTypes *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheInvTypes SET ");
    sql.append("typeID = ");
sql.append(std::to_string(data->typeID));
sql.append(", ");
    sql.append("groupID = ");
sql.append(std::to_string(data->groupID));
sql.append(", ");
    sql.append("typeName = ");
sql.append("'");
sql.append(data->typeName);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("graphicID = ");
sql.append(std::to_string(data->graphicID));
sql.append(", ");
    sql.append("radius = ");
sql.append(std::to_string(data->radius));
sql.append(", ");
    sql.append("mass = ");
sql.append(std::to_string(data->mass));
sql.append(", ");
    sql.append("volume = ");
sql.append(std::to_string(data->volume));
sql.append(", ");
    sql.append("capacity = ");
sql.append(std::to_string(data->capacity));
sql.append(", ");
    sql.append("portionSize = ");
sql.append(std::to_string(data->portionSize));
sql.append(", ");
    sql.append("raceID = ");
sql.append(std::to_string(data->raceID));
sql.append(", ");
    sql.append("basePrice = ");
sql.append(std::to_string(data->basePrice));
sql.append(", ");
    sql.append("published = ");
sql.append(std::to_string(data->published));
sql.append(", ");
    sql.append("marketGroupID = ");
sql.append(std::to_string(data->marketGroupID));
sql.append(", ");
    sql.append("chanceOfDuplicating = ");
sql.append(std::to_string(data->chanceOfDuplicating));
sql.append(", ");
    sql.append("soundID = ");
sql.append(std::to_string(data->soundID));
sql.append(", ");
    sql.append("iconID = ");
sql.append(std::to_string(data->iconID));
sql.append(", ");
    sql.append("dataID = ");
sql.append(std::to_string(data->dataID));
sql.append(", ");
    sql.append("typeNameID = ");
sql.append(std::to_string(data->typeNameID));
sql.append(", ");
    sql.append("descriptionID = ");
sql.append(std::to_string(data->descriptionID));
sql.append(", ");
    sql.append("copyTypeID = ");
sql.append(std::to_string(data->copyTypeID));
   sql.append(" WHERE typeID = ");
   sql.append(std::to_string(data->typeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheResIcons_save(cacheResIcons *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheResIcons SET ");
    sql.append("iconID = ");
sql.append(std::to_string(data->iconID));
sql.append(", ");
    sql.append("iconFile = ");
sql.append("'");
sql.append(data->iconFile);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("obsolete = ");
sql.append(std::to_string(data->obsolete));
sql.append(", ");
    sql.append("iconType = ");
sql.append("'");
sql.append(data->iconType);
sql.append("'");
sql.append(", ");
    sql.append("directoryID = ");
sql.append(std::to_string(data->directoryID));
   sql.append(" WHERE iconID = ");
   sql.append(std::to_string(data->iconID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheActBillTypes_save(cacheActBillTypes *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheActBillTypes SET ");
    sql.append("billTypeID = ");
sql.append(std::to_string(data->billTypeID));
sql.append(", ");
    sql.append("billTypeName = ");
sql.append("'");
sql.append(data->billTypeName);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("billTypeNameID = ");
sql.append(std::to_string(data->billTypeNameID));
sql.append(", ");
    sql.append("dataID = ");
sql.append(std::to_string(data->dataID));
   sql.append(" WHERE billTypeID = ");
   sql.append(std::to_string(data->billTypeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cachePlanetSchematicsPinMap_save(cachePlanetSchematicsPinMap *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cachePlanetSchematicsPinMap SET ");
    sql.append("schematicID = ");
sql.append(std::to_string(data->schematicID));
sql.append(", ");
    sql.append("pinTypeID = ");
sql.append(std::to_string(data->pinTypeID));
   sql.append(" WHERE schematicID = ");
   sql.append(std::to_string(data->schematicID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheInvContrabandTypes_save(cacheInvContrabandTypes *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheInvContrabandTypes SET ");
    sql.append("factionID = ");
sql.append(std::to_string(data->factionID));
sql.append(", ");
    sql.append("typeID = ");
sql.append(std::to_string(data->typeID));
sql.append(", ");
    sql.append("standingLoss = ");
sql.append(std::to_string(data->standingLoss));
sql.append(", ");
    sql.append("confiscateMinSec = ");
sql.append(std::to_string(data->confiscateMinSec));
sql.append(", ");
    sql.append("fineByValue = ");
sql.append(std::to_string(data->fineByValue));
sql.append(", ");
    sql.append("attackMinSec = ");
sql.append(std::to_string(data->attackMinSec));
   sql.append(" WHERE factionID = ");
   sql.append(std::to_string(data->factionID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheInvMetaGroups_save(cacheInvMetaGroups *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheInvMetaGroups SET ");
    sql.append("metaGroupID = ");
sql.append(std::to_string(data->metaGroupID));
sql.append(", ");
    sql.append("metaGroupName = ");
sql.append("'");
sql.append(data->metaGroupName);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("iconID = ");
sql.append(std::to_string(data->iconID));
sql.append(", ");
    sql.append("metaGroupNameID = ");
sql.append(std::to_string(data->metaGroupNameID));
sql.append(", ");
    sql.append("descriptionID = ");
sql.append(std::to_string(data->descriptionID));
sql.append(", ");
    sql.append("dataID = ");
sql.append(std::to_string(data->dataID));
   sql.append(" WHERE metaGroupID = ");
   sql.append(std::to_string(data->metaGroupID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheCertificates_save(cacheCertificates *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheCertificates SET ");
    sql.append("certificateID = ");
sql.append(std::to_string(data->certificateID));
sql.append(", ");
    sql.append("categoryID = ");
sql.append(std::to_string(data->categoryID));
sql.append(", ");
    sql.append("classID = ");
sql.append(std::to_string(data->classID));
sql.append(", ");
    sql.append("grade = ");
sql.append(std::to_string(data->grade));
sql.append(", ");
    sql.append("corpID = ");
sql.append(std::to_string(data->corpID));
sql.append(", ");
    sql.append("iconID = ");
sql.append(std::to_string(data->iconID));
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("descriptionID = ");
sql.append(std::to_string(data->descriptionID));
sql.append(", ");
    sql.append("dataID = ");
sql.append(std::to_string(data->dataID));
   sql.append(" WHERE certificateID = ");
   sql.append(std::to_string(data->certificateID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheInvTypeMaterials_save(cacheInvTypeMaterials *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheInvTypeMaterials SET ");
    sql.append("typeID = ");
sql.append(std::to_string(data->typeID));
sql.append(", ");
    sql.append("materialTypeID = ");
sql.append(std::to_string(data->materialTypeID));
sql.append(", ");
    sql.append("quantity = ");
sql.append(std::to_string(data->quantity));
   sql.append(" WHERE typeID = ");
   sql.append(std::to_string(data->typeID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheResSounds_save(cacheResSounds *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheResSounds SET ");
    sql.append("soundID = ");
sql.append(std::to_string(data->soundID));
sql.append(", ");
    sql.append("soundFile = ");
sql.append("'");
sql.append(data->soundFile);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("obsolete = ");
sql.append(std::to_string(data->obsolete));
   sql.append(" WHERE soundID = ");
   sql.append(std::to_string(data->soundID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void cacheRamActivities_save(cacheRamActivities *data, bulkdata *b) {
    char *err_msg = NULL;
    sqlite3_stmt *res;
    std::string sql("update cacheRamActivities SET ");
    sql.append("activityID = ");
sql.append(std::to_string(data->activityID));
sql.append(", ");
    sql.append("activityName = ");
sql.append("'");
sql.append(data->activityName);
sql.append("'");
sql.append(", ");
    sql.append("iconNo = ");
sql.append("'");
sql.append(data->iconNo);
sql.append("'");
sql.append(", ");
    sql.append("description = ");
sql.append("'");
sql.append(data->description);
sql.append("'");
sql.append(", ");
    sql.append("published = ");
sql.append(std::to_string(data->published));
sql.append(", ");
    sql.append("activityNameID = ");
sql.append(std::to_string(data->activityNameID));
sql.append(", ");
    sql.append("descriptionID = ");
sql.append(std::to_string(data->descriptionID));
   sql.append(" WHERE activityID = ");
   sql.append(std::to_string(data->activityID));
   sql.append(";");
   printf("%s\n\n", sql.c_str());
   printf("db handle %p\n", b->db);
   uint32_t rc = sqlite3_exec(b->db, sql.c_str(), NULL, NULL, &err_msg);
   if (rc != SQLITE_OK) {
       printf("err: %s\n", err_msg);
   }
   printf("err: %s %d\n", err_msg, rc);
   data->dirty = false;
}
void save_all_dirty(cache_collection *cc, bulkdata *b) {
    cacheShipTypes_save_dirty(cc, b);
    cacheStaOperations_save_dirty(cc, b);
    cacheRamAssemblyLineTypesCategory_save_dirty(cc, b);
    cacheInvCategories_save_dirty(cc, b);
    cacheDogmaEffects_save_dirty(cc, b);
    cacheRamCompletedStatuses_save_dirty(cc, b);
    cacheInvBlueprintTypes_save_dirty(cc, b);
    cacheRamTypeRequirements_save_dirty(cc, b);
    cacheCertificateRelationships_save_dirty(cc, b);
    cacheDogmaAttributes_save_dirty(cc, b);
    cacheRamAssemblyLineTypes_save_dirty(cc, b);
    cacheStaStationsStatic_save_dirty(cc, b);
    cacheInvGroups_save_dirty(cc, b);
    cacheInvMetaTypes_save_dirty(cc, b);
    cacheInvTypeReactions_save_dirty(cc, b);
    cacheDogmaTypeEffects_save_dirty(cc, b);
    cachePlanetSchematics_save_dirty(cc, b);
    cacheDogmaUnits_save_dirty(cc, b);
    cachePlanetSchematicsTypeMap_save_dirty(cc, b);
    cacheDogmaTypeAttributes_save_dirty(cc, b);
    cacheDogmaExpressions_save_dirty(cc, b);
    cacheRamAssemblyLineTypesGroup_save_dirty(cc, b);
    cacheResGraphics_save_dirty(cc, b);
    cacheInvTypes_save_dirty(cc, b);
    cacheResIcons_save_dirty(cc, b);
    cacheActBillTypes_save_dirty(cc, b);
    cachePlanetSchematicsPinMap_save_dirty(cc, b);
    cacheInvContrabandTypes_save_dirty(cc, b);
    cacheInvMetaGroups_save_dirty(cc, b);
    cacheCertificates_save_dirty(cc, b);
    cacheInvTypeMaterials_save_dirty(cc, b);
    cacheResSounds_save_dirty(cc, b);
    cacheRamActivities_save_dirty(cc, b);
}

void cacheShipTypes_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheShipTypes;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheShipTypes_save(di, b);
            cc->cache_cacheShipTypes[i].dirty = false;
        }
    }
}
void cacheStaOperations_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheStaOperations;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheStaOperations_save(di, b);
            cc->cache_cacheStaOperations[i].dirty = false;
        }
    }
}
void cacheRamAssemblyLineTypesCategory_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheRamAssemblyLineTypesCategory;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheRamAssemblyLineTypesCategory_save(di, b);
            cc->cache_cacheRamAssemblyLineTypesCategory[i].dirty = false;
        }
    }
}
void cacheInvCategories_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheInvCategories;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheInvCategories_save(di, b);
            cc->cache_cacheInvCategories[i].dirty = false;
        }
    }
}
void cacheDogmaEffects_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheDogmaEffects;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheDogmaEffects_save(di, b);
            cc->cache_cacheDogmaEffects[i].dirty = false;
        }
    }
}
void cacheRamCompletedStatuses_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheRamCompletedStatuses;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheRamCompletedStatuses_save(di, b);
            cc->cache_cacheRamCompletedStatuses[i].dirty = false;
        }
    }
}
void cacheInvBlueprintTypes_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheInvBlueprintTypes;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheInvBlueprintTypes_save(di, b);
            cc->cache_cacheInvBlueprintTypes[i].dirty = false;
        }
    }
}
void cacheRamTypeRequirements_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheRamTypeRequirements;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheRamTypeRequirements_save(di, b);
            cc->cache_cacheRamTypeRequirements[i].dirty = false;
        }
    }
}
void cacheCertificateRelationships_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheCertificateRelationships;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheCertificateRelationships_save(di, b);
            cc->cache_cacheCertificateRelationships[i].dirty = false;
        }
    }
}
void cacheDogmaAttributes_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheDogmaAttributes;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheDogmaAttributes_save(di, b);
            cc->cache_cacheDogmaAttributes[i].dirty = false;
        }
    }
}
void cacheRamAssemblyLineTypes_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheRamAssemblyLineTypes;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheRamAssemblyLineTypes_save(di, b);
            cc->cache_cacheRamAssemblyLineTypes[i].dirty = false;
        }
    }
}
void cacheStaStationsStatic_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheStaStationsStatic;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheStaStationsStatic_save(di, b);
            cc->cache_cacheStaStationsStatic[i].dirty = false;
        }
    }
}
void cacheInvGroups_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheInvGroups;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheInvGroups_save(di, b);
            cc->cache_cacheInvGroups[i].dirty = false;
        }
    }
}
void cacheInvMetaTypes_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheInvMetaTypes;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheInvMetaTypes_save(di, b);
            cc->cache_cacheInvMetaTypes[i].dirty = false;
        }
    }
}
void cacheInvTypeReactions_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheInvTypeReactions;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheInvTypeReactions_save(di, b);
            cc->cache_cacheInvTypeReactions[i].dirty = false;
        }
    }
}
void cacheDogmaTypeEffects_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheDogmaTypeEffects;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheDogmaTypeEffects_save(di, b);
            cc->cache_cacheDogmaTypeEffects[i].dirty = false;
        }
    }
}
void cachePlanetSchematics_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cachePlanetSchematics;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cachePlanetSchematics_save(di, b);
            cc->cache_cachePlanetSchematics[i].dirty = false;
        }
    }
}
void cacheDogmaUnits_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheDogmaUnits;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheDogmaUnits_save(di, b);
            cc->cache_cacheDogmaUnits[i].dirty = false;
        }
    }
}
void cachePlanetSchematicsTypeMap_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cachePlanetSchematicsTypeMap;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cachePlanetSchematicsTypeMap_save(di, b);
            cc->cache_cachePlanetSchematicsTypeMap[i].dirty = false;
        }
    }
}
void cacheDogmaTypeAttributes_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheDogmaTypeAttributes;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheDogmaTypeAttributes_save(di, b);
            cc->cache_cacheDogmaTypeAttributes[i].dirty = false;
        }
    }
}
void cacheDogmaExpressions_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheDogmaExpressions;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheDogmaExpressions_save(di, b);
            cc->cache_cacheDogmaExpressions[i].dirty = false;
        }
    }
}
void cacheRamAssemblyLineTypesGroup_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheRamAssemblyLineTypesGroup;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheRamAssemblyLineTypesGroup_save(di, b);
            cc->cache_cacheRamAssemblyLineTypesGroup[i].dirty = false;
        }
    }
}
void cacheResGraphics_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheResGraphics;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheResGraphics_save(di, b);
            cc->cache_cacheResGraphics[i].dirty = false;
        }
    }
}
void cacheInvTypes_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheInvTypes;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheInvTypes_save(di, b);
            cc->cache_cacheInvTypes[i].dirty = false;
        }
    }
}
void cacheResIcons_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheResIcons;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheResIcons_save(di, b);
            cc->cache_cacheResIcons[i].dirty = false;
        }
    }
}
void cacheActBillTypes_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheActBillTypes;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheActBillTypes_save(di, b);
            cc->cache_cacheActBillTypes[i].dirty = false;
        }
    }
}
void cachePlanetSchematicsPinMap_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cachePlanetSchematicsPinMap;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cachePlanetSchematicsPinMap_save(di, b);
            cc->cache_cachePlanetSchematicsPinMap[i].dirty = false;
        }
    }
}
void cacheInvContrabandTypes_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheInvContrabandTypes;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheInvContrabandTypes_save(di, b);
            cc->cache_cacheInvContrabandTypes[i].dirty = false;
        }
    }
}
void cacheInvMetaGroups_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheInvMetaGroups;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheInvMetaGroups_save(di, b);
            cc->cache_cacheInvMetaGroups[i].dirty = false;
        }
    }
}
void cacheCertificates_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheCertificates;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheCertificates_save(di, b);
            cc->cache_cacheCertificates[i].dirty = false;
        }
    }
}
void cacheInvTypeMaterials_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheInvTypeMaterials;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheInvTypeMaterials_save(di, b);
            cc->cache_cacheInvTypeMaterials[i].dirty = false;
        }
    }
}
void cacheResSounds_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheResSounds;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheResSounds_save(di, b);
            cc->cache_cacheResSounds[i].dirty = false;
        }
    }
}
void cacheRamActivities_save_dirty(cache_collection *cc, bulkdata *b) {
    auto data = cc->cache_cacheRamActivities;
    for (uint32_t i = 0; i < data.size(); i++) {        if (data[i].dirty) {            auto di = &data[i];
            printf("Saving dirty record %p\n", di);
            cacheRamActivities_save(di, b);
            cc->cache_cacheRamActivities[i].dirty = false;
        }
    }
}
